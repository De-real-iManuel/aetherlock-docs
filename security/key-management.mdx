---
title: "Key Management"
description: "Private key storage, rotation procedures, and secret management best practices for AetherLock"
---

# Key Management

Secure key management is critical for AetherLock's operation across multiple blockchain networks and external services. This document outlines best practices for private key storage, key rotation procedures, environment variable security, and secret management using AWS Secrets Manager and Vercel KV.

## Private Key Storage Best Practices

### Development Environment

#### Local Development

```typescript
// .env.local (NEVER commit to version control)
# Solana Keys
SOLANA_PRIVATE_KEY=base58_encoded_private_key_here
SOLANA_RPC_URL=https://api.devnet.solana.com

# ZetaChain Keys  
ZETACHAIN_PRIVATE_KEY=0x1234567890abcdef...
ZETACHAIN_RPC_URL=https://zetachain-athens-evm.blockpi.network/v1/rpc/public

# AI Service Keys
AWS_ACCESS_KEY_ID=AKIA...
AWS_SECRET_ACCESS_KEY=...
AWS_REGION=us-east-1

# zkMe Integration
ZKME_APP_ID=your_app_id
ZKME_API_KEY=your_api_key
ZKME_WEBHOOK_SECRET=your_webhook_secret
```

#### Environment Variable Validation

```typescript
import { z } from 'zod';

const envSchema = z.object({
  // Solana Configuration
  SOLANA_PRIVATE_KEY: z.string().min(1, "Solana private key required"),
  SOLANA_RPC_URL: z.string().url("Valid Solana RPC URL required"),
  
  // ZetaChain Configuration
  ZETACHAIN_PRIVATE_KEY: z.string().regex(/^0x[a-fA-F0-9]{64}$/, "Valid Ethereum private key required"),
  ZETACHAIN_RPC_URL: z.string().url("Valid ZetaChain RPC URL required"),
  
  // AWS Configuration
  AWS_ACCESS_KEY_ID: z.string().min(1, "AWS Access Key ID required"),
  AWS_SECRET_ACCESS_KEY: z.string().min(1, "AWS Secret Access Key required"),
  AWS_REGION: z.string().min(1, "AWS Region required"),
  
  // zkMe Configuration
  ZKME_APP_ID: z.string().min(1, "zkMe App ID required"),
  ZKME_API_KEY: z.string().min(1, "zkMe API Key required"),
  ZKME_WEBHOOK_SECRET: z.string().min(1, "zkMe Webhook Secret required"),
  
  // Optional Configuration
  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
});

export type Environment = z.infer<typeof envSchema>;

export function validateEnvironment(): Environment {
  try {
    return envSchema.parse(process.env);
  } catch (error) {
    console.error('Environment validation failed:', error);
    process.exit(1);
  }
}

// Usage in application startup
const env = validateEnvironment();
```

#### Secure Key Loading

```typescript
import { Keypair } from '@solana/web3.js';
import { Wallet } from 'ethers';
import bs58 from 'bs58';

class SecureKeyManager {
  private solanaKeypair: Keypair | null = null;
  private ethereumWallet: Wallet | null = null;
  
  constructor(private env: Environment) {}

  /**
   * Load Solana keypair from environment
   */
  getSolanaKeypair(): Keypair {
    if (!this.solanaKeypair) {
      try {
        // Support both base58 and JSON array formats
        const privateKeyStr = this.env.SOLANA_PRIVATE_KEY;
        
        let privateKeyBytes: Uint8Array;
        
        if (privateKeyStr.startsWith('[')) {
          // JSON array format: [1,2,3,...]
          const keyArray = JSON.parse(privateKeyStr);
          privateKeyBytes = new Uint8Array(keyArray);
        } else {
          // Base58 format
          privateKeyBytes = bs58.decode(privateKeyStr);
        }
        
        this.solanaKeypair = Keypair.fromSecretKey(privateKeyBytes);
      } catch (error) {
        throw new Error(`Failed to load Solana keypair: ${error.message}`);
      }
    }
    
    return this.solanaKeypair;
  }

  /**
   * Load Ethereum wallet from environment
   */
  getEthereumWallet(): Wallet {
    if (!this.ethereumWallet) {
      try {
        this.ethereumWallet = new Wallet(this.env.ZETACHAIN_PRIVATE_KEY);
      } catch (error) {
        throw new Error(`Failed to load Ethereum wallet: ${error.message}`);
      }
    }
    
    return this.ethereumWallet;
  }

  /**
   * Get public keys for verification
   */
  getPublicKeys(): {
    solana: string;
    ethereum: string;
  } {
    return {
      solana: this.getSolanaKeypair().publicKey.toBase58(),
      ethereum: this.getEthereumWallet().address,
    };
  }

  /**
   * Clear keys from memory (call on shutdown)
   */
  clearKeys(): void {
    this.solanaKeypair = null;
    this.ethereumWallet = null;
  }
}
```

### Production Environment

#### AWS Secrets Manager Integration

```typescript
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';

class AWSSecretsManager {
  private client: SecretsManagerClient;
  private cache: Map<string, { value: any; expiry: number }> = new Map();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes

  constructor(region: string) {
    this.client = new SecretsManagerClient({ region });
  }

  /**
   * Retrieve secret from AWS Secrets Manager with caching
   */
  async getSecret(secretName: string): Promise<any> {
    // Check cache first
    const cached = this.cache.get(secretName);
    if (cached && Date.now() < cached.expiry) {
      return cached.value;
    }

    try {
      const command = new GetSecretValueCommand({
        SecretId: secretName,
      });

      const response = await this.client.send(command);
      const secret = JSON.parse(response.SecretString || '{}');

      // Cache the result
      this.cache.set(secretName, {
        value: secret,
        expiry: Date.now() + this.CACHE_TTL,
      });

      return secret;
    } catch (error) {
      throw new Error(`Failed to retrieve secret ${secretName}: ${error.message}`);
    }
  }

  /**
   * Update secret in AWS Secrets Manager
   */
  async updateSecret(secretName: string, secretValue: any): Promise<void> {
    try {
      const { UpdateSecretCommand } = await import('@aws-sdk/client-secrets-manager');
      
      const command = new UpdateSecretCommand({
        SecretId: secretName,
        SecretString: JSON.stringify(secretValue),
      });

      await this.client.send(command);
      
      // Clear cache for this secret
      this.cache.delete(secretName);
    } catch (error) {
      throw new Error(`Failed to update secret ${secretName}: ${error.message}`);
    }
  }
}

// Production key manager using AWS Secrets Manager
class ProductionKeyManager extends SecureKeyManager {
  private secretsManager: AWSSecretsManager;

  constructor(region: string) {
    super({} as Environment); // Empty env for production
    this.secretsManager = new AWSSecretsManager(region);
  }

  async initialize(): Promise<void> {
    try {
      // Load all secrets at startup
      const secrets = await this.secretsManager.getSecret('aetherlock/production/keys');
      
      // Validate required keys exist
      const requiredKeys = [
        'SOLANA_PRIVATE_KEY',
        'ZETACHAIN_PRIVATE_KEY',
        'AWS_ACCESS_KEY_ID',
        'AWS_SECRET_ACCESS_KEY',
        'ZKME_API_KEY',
        'ZKME_WEBHOOK_SECRET'
      ];

      for (const key of requiredKeys) {
        if (!secrets[key]) {
          throw new Error(`Missing required secret: ${key}`);
        }
      }

      // Initialize keypairs
      this.env = secrets as Environment;
    } catch (error) {
      throw new Error(`Failed to initialize production keys: ${error.message}`);
    }
  }
}
```

#### Vercel KV Integration

```typescript
import { kv } from '@vercel/kv';

class VercelKVSecretManager {
  private readonly KEY_PREFIX = 'aetherlock:secrets:';
  private readonly ENCRYPTION_KEY: string;

  constructor(encryptionKey: string) {
    this.ENCRYPTION_KEY = encryptionKey;
  }

  /**
   * Store encrypted secret in Vercel KV
   */
  async storeSecret(key: string, value: string): Promise<void> {
    try {
      const encrypted = await this.encrypt(value);
      await kv.set(`${this.KEY_PREFIX}${key}`, encrypted);
    } catch (error) {
      throw new Error(`Failed to store secret ${key}: ${error.message}`);
    }
  }

  /**
   * Retrieve and decrypt secret from Vercel KV
   */
  async getSecret(key: string): Promise<string | null> {
    try {
      const encrypted = await kv.get<string>(`${this.KEY_PREFIX}${key}`);
      if (!encrypted) return null;
      
      return await this.decrypt(encrypted);
    } catch (error) {
      throw new Error(`Failed to retrieve secret ${key}: ${error.message}`);
    }
  }

  /**
   * Delete secret from Vercel KV
   */
  async deleteSecret(key: string): Promise<void> {
    try {
      await kv.del(`${this.KEY_PREFIX}${key}`);
    } catch (error) {
      throw new Error(`Failed to delete secret ${key}: ${error.message}`);
    }
  }

  /**
   * Encrypt value using AES-256-GCM
   */
  private async encrypt(value: string): Promise<string> {
    const crypto = await import('crypto');
    
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher('aes-256-gcm', this.ENCRYPTION_KEY);
    
    let encrypted = cipher.update(value, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
  }

  /**
   * Decrypt value using AES-256-GCM
   */
  private async decrypt(encryptedValue: string): Promise<string> {
    const crypto = await import('crypto');
    
    const [ivHex, authTagHex, encrypted] = encryptedValue.split(':');
    
    const iv = Buffer.from(ivHex, 'hex');
    const authTag = Buffer.from(authTagHex, 'hex');
    
    const decipher = crypto.createDecipher('aes-256-gcm', this.ENCRYPTION_KEY);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

## Key Rotation Procedures

### Automated Key Rotation

```typescript
interface KeyRotationConfig {
  rotationIntervalDays: number;
  backupKeyCount: number;
  notificationWebhook?: string;
}

class KeyRotationManager {
  private config: KeyRotationConfig;
  private secretsManager: AWSSecretsManager;

  constructor(config: KeyRotationConfig, secretsManager: AWSSecretsManager) {
    this.config = config;
    this.secretsManager = secretsManager;
  }

  /**
   * Check if keys need rotation
   */
  async checkRotationNeeded(): Promise<boolean> {
    try {
      const metadata = await this.secretsManager.getSecret('aetherlock/key-metadata');
      const lastRotation = new Date(metadata.lastRotation);
      const daysSinceRotation = (Date.now() - lastRotation.getTime()) / (1000 * 60 * 60 * 24);
      
      return daysSinceRotation >= this.config.rotationIntervalDays;
    } catch (error) {
      // If metadata doesn't exist, rotation is needed
      return true;
    }
  }

  /**
   * Rotate all system keys
   */
  async rotateKeys(): Promise<void> {
    console.log('Starting key rotation process...');

    try {
      // 1. Generate new keys
      const newKeys = await this.generateNewKeys();
      
      // 2. Backup current keys
      await this.backupCurrentKeys();
      
      // 3. Update secrets with new keys
      await this.updateSecretsWithNewKeys(newKeys);
      
      // 4. Update on-chain authorities (if needed)
      await this.updateOnChainAuthorities(newKeys);
      
      // 5. Update metadata
      await this.updateRotationMetadata();
      
      // 6. Send notification
      await this.sendRotationNotification('success');
      
      console.log('Key rotation completed successfully');
    } catch (error) {
      await this.sendRotationNotification('failed', error.message);
      throw error;
    }
  }

  /**
   * Generate new cryptographic keys
   */
  private async generateNewKeys(): Promise<{
    solana: Keypair;
    ethereum: Wallet;
    aiSigning: Keypair;
  }> {
    return {
      solana: Keypair.generate(),
      ethereum: Wallet.createRandom(),
      aiSigning: Keypair.generate(),
    };
  }

  /**
   * Backup current keys before rotation
   */
  private async backupCurrentKeys(): Promise<void> {
    const currentKeys = await this.secretsManager.getSecret('aetherlock/production/keys');
    const backupName = `aetherlock/backup/keys-${Date.now()}`;
    
    await this.secretsManager.updateSecret(backupName, {
      ...currentKeys,
      backedUpAt: new Date().toISOString(),
    });

    // Clean up old backups (keep only configured number)
    await this.cleanupOldBackups();
  }

  /**
   * Update secrets with new keys
   */
  private async updateSecretsWithNewKeys(newKeys: any): Promise<void> {
    const updatedSecrets = {
      SOLANA_PRIVATE_KEY: bs58.encode(newKeys.solana.secretKey),
      ZETACHAIN_PRIVATE_KEY: newKeys.ethereum.privateKey,
      AI_SIGNING_KEY: bs58.encode(newKeys.aiSigning.secretKey),
      // Keep other non-rotated secrets
      ...(await this.getNonRotatedSecrets()),
    };

    await this.secretsManager.updateSecret('aetherlock/production/keys', updatedSecrets);
  }

  /**
   * Update on-chain program authorities
   */
  private async updateOnChainAuthorities(newKeys: any): Promise<void> {
    // Update Solana program authority
    await this.updateSolanaProgramAuthority(newKeys.solana);
    
    // Update ZetaChain contract owner
    await this.updateZetaChainContractOwner(newKeys.ethereum);
  }

  /**
   * Send rotation notification
   */
  private async sendRotationNotification(
    status: 'success' | 'failed',
    error?: string
  ): Promise<void> {
    if (!this.config.notificationWebhook) return;

    const payload = {
      status,
      timestamp: new Date().toISOString(),
      error,
      rotatedKeys: ['solana', 'ethereum', 'ai-signing'],
    };

    try {
      await fetch(this.config.notificationWebhook, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
    } catch (error) {
      console.error('Failed to send rotation notification:', error);
    }
  }
}
```

### Manual Key Rotation

```bash
#!/bin/bash
# manual-key-rotation.sh

set -e

echo "Starting manual key rotation for AetherLock..."

# 1. Backup current keys
echo "Backing up current keys..."
aws secretsmanager get-secret-value \
  --secret-id "aetherlock/production/keys" \
  --query SecretString --output text > backup-$(date +%Y%m%d-%H%M%S).json

# 2. Generate new Solana keypair
echo "Generating new Solana keypair..."
solana-keygen new --no-bip39-passphrase --silent --outfile new-solana-key.json

# 3. Generate new Ethereum private key
echo "Generating new Ethereum private key..."
node -e "
const { Wallet } = require('ethers');
const wallet = Wallet.createRandom();
console.log(wallet.privateKey);
" > new-ethereum-key.txt

# 4. Update AWS Secrets Manager
echo "Updating secrets..."
SOLANA_KEY=$(cat new-solana-key.json | jq -c .)
ETHEREUM_KEY=$(cat new-ethereum-key.txt)

aws secretsmanager update-secret \
  --secret-id "aetherlock/production/keys" \
  --secret-string "{
    \"SOLANA_PRIVATE_KEY\": \"$SOLANA_KEY\",
    \"ZETACHAIN_PRIVATE_KEY\": \"$ETHEREUM_KEY\"
  }"

# 5. Clean up temporary files
rm new-solana-key.json new-ethereum-key.txt

echo "Key rotation completed successfully!"
echo "Remember to update on-chain authorities with new public keys."
```

## Environment Variable Security

### Development Security

```typescript
// scripts/validate-env-security.ts
import fs from 'fs';
import path from 'path';

interface SecurityCheck {
  name: string;
  check: () => boolean;
  severity: 'error' | 'warning';
  message: string;
}

class EnvironmentSecurityValidator {
  private checks: SecurityCheck[] = [
    {
      name: 'no-env-in-git',
      check: () => !fs.existsSync('.env') || this.isInGitignore('.env'),
      severity: 'error',
      message: '.env file should not be committed to git'
    },
    {
      name: 'no-hardcoded-keys',
      check: () => this.checkForHardcodedKeys(),
      severity: 'error',
      message: 'No hardcoded private keys found in source code'
    },
    {
      name: 'env-example-exists',
      check: () => fs.existsSync('.env.example'),
      severity: 'warning',
      message: '.env.example file should exist as template'
    },
    {
      name: 'secure-key-format',
      check: () => this.validateKeyFormats(),
      severity: 'error',
      message: 'All private keys should use secure formats'
    }
  ];

  async runSecurityChecks(): Promise<void> {
    console.log('Running environment security checks...\n');

    let hasErrors = false;
    let hasWarnings = false;

    for (const check of this.checks) {
      const passed = check.check();
      const status = passed ? '✅' : (check.severity === 'error' ? '❌' : '⚠️');
      
      console.log(`${status} ${check.name}: ${check.message}`);
      
      if (!passed) {
        if (check.severity === 'error') {
          hasErrors = true;
        } else {
          hasWarnings = true;
        }
      }
    }

    console.log('\n' + '='.repeat(50));
    
    if (hasErrors) {
      console.log('❌ Security check failed! Fix errors before proceeding.');
      process.exit(1);
    } else if (hasWarnings) {
      console.log('⚠️  Security check passed with warnings.');
    } else {
      console.log('✅ All security checks passed!');
    }
  }

  private isInGitignore(file: string): boolean {
    try {
      const gitignore = fs.readFileSync('.gitignore', 'utf8');
      return gitignore.includes(file);
    } catch {
      return false;
    }
  }

  private checkForHardcodedKeys(): boolean {
    const patterns = [
      /[0-9a-fA-F]{64}/, // 64-char hex (Ethereum private key)
      /[1-9A-HJ-NP-Za-km-z]{87,88}/, // Base58 (Solana private key)
      /AKIA[0-9A-Z]{16}/, // AWS Access Key
    ];

    const sourceFiles = this.getSourceFiles();
    
    for (const file of sourceFiles) {
      const content = fs.readFileSync(file, 'utf8');
      
      for (const pattern of patterns) {
        if (pattern.test(content)) {
          console.log(`⚠️  Potential hardcoded key found in ${file}`);
          return false;
        }
      }
    }

    return true;
  }

  private validateKeyFormats(): boolean {
    if (!fs.existsSync('.env')) return true;

    const envContent = fs.readFileSync('.env', 'utf8');
    const lines = envContent.split('\n');

    for (const line of lines) {
      if (line.includes('PRIVATE_KEY=') && !line.includes('your_key_here')) {
        const value = line.split('=')[1];
        
        // Check if it looks like a real key (not placeholder)
        if (value && value.length > 20 && !value.includes('placeholder')) {
          console.log(`⚠️  Real private key detected in .env file: ${line.split('=')[0]}`);
          return false;
        }
      }
    }

    return true;
  }

  private getSourceFiles(): string[] {
    const extensions = ['.ts', '.js', '.tsx', '.jsx'];
    const files: string[] = [];

    function walkDir(dir: string) {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
          walkDir(fullPath);
        } else if (stat.isFile() && extensions.some(ext => item.endsWith(ext))) {
          files.push(fullPath);
        }
      }
    }

    walkDir('.');
    return files;
  }
}

// Run security validation
new EnvironmentSecurityValidator().runSecurityChecks();
```

### Production Security

```typescript
// middleware/security-headers.ts
export function securityHeaders() {
  return {
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Referrer-Policy': 'strict-origin-when-cross-origin',
    'Content-Security-Policy': [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "connect-src 'self' https://api.devnet.solana.com https://zetachain-athens-evm.blockpi.network",
      "frame-ancestors 'none'",
    ].join('; '),
  };
}

// Rate limiting for key operations
export class KeyOperationRateLimit {
  private attempts: Map<string, number[]> = new Map();
  private readonly maxAttempts = 5;
  private readonly windowMs = 15 * 60 * 1000; // 15 minutes

  isAllowed(identifier: string): boolean {
    const now = Date.now();
    const attempts = this.attempts.get(identifier) || [];
    
    // Remove old attempts outside the window
    const recentAttempts = attempts.filter(time => now - time < this.windowMs);
    
    if (recentAttempts.length >= this.maxAttempts) {
      return false;
    }

    // Record this attempt
    recentAttempts.push(now);
    this.attempts.set(identifier, recentAttempts);
    
    return true;
  }
}
```

## Secret Management Options

### AWS Secrets Manager Setup

```bash
# Create secrets in AWS Secrets Manager
aws secretsmanager create-secret \
  --name "aetherlock/production/keys" \
  --description "AetherLock production private keys" \
  --secret-string '{
    "SOLANA_PRIVATE_KEY": "your_base58_encoded_key",
    "ZETACHAIN_PRIVATE_KEY": "0x1234567890abcdef...",
    "AWS_ACCESS_KEY_ID": "AKIA...",
    "AWS_SECRET_ACCESS_KEY": "...",
    "ZKME_API_KEY": "...",
    "ZKME_WEBHOOK_SECRET": "..."
  }'

# Set up automatic rotation
aws secretsmanager rotate-secret \
  --secret-id "aetherlock/production/keys" \
  --rotation-rules AutomaticallyAfterDays=30
```

### Vercel KV Setup

```bash
# Install Vercel CLI and set up KV
npm i -g vercel
vercel login
vercel link

# Create KV database
vercel kv create aetherlock-secrets

# Set environment variables in Vercel
vercel env add KV_URL
vercel env add KV_REST_API_URL
vercel env add KV_REST_API_TOKEN
vercel env add KV_REST_API_READ_ONLY_TOKEN
```

### Docker Secrets

```dockerfile
# Dockerfile with secrets support
FROM node:18-alpine

# Create app directory
WORKDIR /usr/src/app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY . .

# Use Docker secrets for sensitive data
RUN --mount=type=secret,id=solana_key \
    --mount=type=secret,id=ethereum_key \
    echo "Keys loaded from Docker secrets"

# Run as non-root user
USER node

EXPOSE 3000
CMD ["npm", "start"]
```

```bash
# Build with secrets
echo "your_solana_key" | docker secret create solana_key -
echo "your_ethereum_key" | docker secret create ethereum_key -

docker build --secret id=solana_key --secret id=ethereum_key -t aetherlock .
```

## Security Audit Checklist

### Key Storage Security
- [ ] **No Hardcoded Keys**: No private keys in source code
- [ ] **Environment Isolation**: Separate keys for dev/staging/production
- [ ] **Encryption at Rest**: All stored keys are encrypted
- [ ] **Access Logging**: All key access is logged and monitored
- [ ] **Backup Security**: Key backups are encrypted and access-controlled

### Key Rotation Security
- [ ] **Automated Rotation**: Keys rotate automatically on schedule
- [ ] **Graceful Transition**: Old keys remain valid during transition period
- [ ] **Rollback Capability**: Ability to rollback to previous keys if needed
- [ ] **Notification System**: Alerts sent on rotation success/failure
- [ ] **Audit Trail**: Complete log of all rotation activities

### Access Control Security
- [ ] **Principle of Least Privilege**: Minimal required permissions only
- [ ] **Multi-Factor Authentication**: MFA required for key access
- [ ] **IP Restrictions**: Key access restricted to authorized IPs
- [ ] **Time-Based Access**: Keys have expiration times where appropriate
- [ ] **Emergency Procedures**: Clear process for emergency key revocation

### Operational Security
- [ ] **Monitoring**: Real-time monitoring of key usage
- [ ] **Alerting**: Immediate alerts on suspicious key activity
- [ ] **Incident Response**: Clear procedures for key compromise
- [ ] **Recovery Procedures**: Documented key recovery processes
- [ ] **Regular Audits**: Periodic security audits of key management

This comprehensive key management system ensures AetherLock maintains the highest security standards while providing operational flexibility and disaster recovery capabilities.