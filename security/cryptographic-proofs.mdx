---
title: "Cryptographic Proofs"
description: "Ed25519 signatures, zero-knowledge proofs, and AI result authentication in AetherLock"
---

# Cryptographic Proofs

AetherLock employs multiple cryptographic primitives to ensure security, authenticity, and privacy across the protocol. This document details the signature schemes, zero-knowledge proofs, and authentication mechanisms used throughout the system.

## Ed25519 Signature Schemes

### Overview

AetherLock uses Ed25519 signatures for:
- AI verification result authentication
- Cross-chain message signing
- User action authorization
- Oracle data integrity

Ed25519 provides:
- **High Performance**: Fast signature generation and verification
- **Small Signatures**: 64-byte signatures with 32-byte public keys
- **Security**: 128-bit security level with resistance to side-channel attacks
- **Deterministic**: Same message always produces the same signature

### AI Result Authentication

The AI verification system signs all results using Ed25519 to prevent tampering and ensure authenticity.

#### Signature Generation (Backend)

```typescript
import { Keypair } from '@solana/web3.js';
import { sign } from 'tweetnacl';
import { encode } from 'bs58';

interface AIVerificationResult {
  escrowId: string;
  confidence: number;
  decision: 'approved' | 'rejected' | 'review';
  timestamp: number;
  evidenceHash: string;
}

class AIResultSigner {
  private keypair: Keypair;

  constructor(privateKey?: Uint8Array) {
    this.keypair = privateKey 
      ? Keypair.fromSecretKey(privateKey)
      : Keypair.generate();
  }

  /**
   * Sign AI verification result with Ed25519
   */
  signResult(result: AIVerificationResult): {
    signature: string;
    publicKey: string;
    signedData: string;
  } {
    // Create canonical message format
    const message = this.createCanonicalMessage(result);
    const messageBytes = new TextEncoder().encode(message);
    
    // Generate Ed25519 signature
    const signature = sign.detached(messageBytes, this.keypair.secretKey);
    
    return {
      signature: encode(signature),
      publicKey: this.keypair.publicKey.toBase58(),
      signedData: message
    };
  }

  /**
   * Create deterministic message format for signing
   */
  private createCanonicalMessage(result: AIVerificationResult): string {
    return [
      `escrow:${result.escrowId}`,
      `confidence:${result.confidence.toFixed(6)}`,
      `decision:${result.decision}`,
      `timestamp:${result.timestamp}`,
      `evidence:${result.evidenceHash}`
    ].join('|');
  }

  /**
   * Get public key for verification
   */
  getPublicKey(): string {
    return this.keypair.publicKey.toBase58();
  }
}

// Usage example
const signer = new AIResultSigner();

const verificationResult: AIVerificationResult = {
  escrowId: "ESC_123456789",
  confidence: 0.94,
  decision: "approved",
  timestamp: Date.now(),
  evidenceHash: "QmX7Y8Z9..."
};

const signedResult = signer.signResult(verificationResult);
console.log("Signature:", signedResult.signature);
console.log("Public Key:", signedResult.publicKey);
```

#### Signature Verification (Smart Contract)

```rust
use anchor_lang::prelude::*;
use ed25519_dalek::{PublicKey, Signature, Verifier};

#[derive(Accounts)]
pub struct VerifyAIResult<'info> {
    #[account(mut)]
    pub escrow: Account<'info, EscrowAccount>,
    pub ai_authority: Signer<'info>,
}

#[account]
pub struct EscrowAccount {
    pub id: String,
    pub ai_public_key: [u8; 32],
    pub verification_result: Option<AIResult>,
    // ... other fields
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct AIResult {
    pub confidence: u64, // Fixed-point representation (6 decimals)
    pub decision: Decision,
    pub timestamp: i64,
    pub evidence_hash: String,
    pub signature: [u8; 64],
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum Decision {
    Approved,
    Rejected,
    Review,
}

impl<'info> VerifyAIResult<'info> {
    pub fn verify_ai_signature(
        ctx: Context<VerifyAIResult>,
        result: AIResult,
    ) -> Result<()> {
        let escrow = &mut ctx.accounts.escrow;
        
        // Reconstruct the signed message
        let message = format!(
            "escrow:{}|confidence:{:.6}|decision:{}|timestamp:{}|evidence:{}",
            escrow.id,
            result.confidence as f64 / 1_000_000.0,
            match result.decision {
                Decision::Approved => "approved",
                Decision::Rejected => "rejected",
                Decision::Review => "review",
            },
            result.timestamp,
            result.evidence_hash
        );
        
        // Verify Ed25519 signature
        let public_key = PublicKey::from_bytes(&escrow.ai_public_key)
            .map_err(|_| ErrorCode::InvalidPublicKey)?;
        
        let signature = Signature::from_bytes(&result.signature)
            .map_err(|_| ErrorCode::InvalidSignature)?;
        
        public_key
            .verify(message.as_bytes(), &signature)
            .map_err(|_| ErrorCode::SignatureVerificationFailed)?;
        
        // Store verified result
        escrow.verification_result = Some(result);
        
        msg!("AI result signature verified successfully");
        Ok(())
    }
}

#[error_code]
pub enum ErrorCode {
    #[msg("Invalid public key format")]
    InvalidPublicKey,
    #[msg("Invalid signature format")]
    InvalidSignature,
    #[msg("Signature verification failed")]
    SignatureVerificationFailed,
}
```

### Cross-Chain Message Signing

For ZetaChain Universal App integration, messages are signed to ensure integrity across chains.

```typescript
import { ethers } from 'ethers';

class CrossChainSigner {
  private wallet: ethers.Wallet;

  constructor(privateKey: string) {
    this.wallet = new ethers.Wallet(privateKey);
  }

  /**
   * Sign cross-chain message for ZetaChain
   */
  async signCrossChainMessage(
    sourceChain: string,
    destinationChain: string,
    payload: any,
    nonce: number
  ): Promise<{
    signature: string;
    messageHash: string;
    signer: string;
  }> {
    // Create message hash
    const message = ethers.utils.solidityKeccak256(
      ['string', 'string', 'bytes', 'uint256'],
      [sourceChain, destinationChain, ethers.utils.toUtf8Bytes(JSON.stringify(payload)), nonce]
    );

    // Sign with ECDSA (for Ethereum compatibility)
    const signature = await this.wallet.signMessage(ethers.utils.arrayify(message));

    return {
      signature,
      messageHash: message,
      signer: this.wallet.address
    };
  }
}
```

## Zero-Knowledge Proofs

### zkMe Integration

AetherLock integrates with zkMe for privacy-preserving KYC verification using zero-knowledge proofs.

#### Proof Generation (Frontend)

```typescript
import { ZkMeWidget } from '@zkme/widget';

interface ZKProofResult {
  proof: string;
  publicSignals: string[];
  verificationKey: string;
}

class ZKMeProofGenerator {
  private widget: ZkMeWidget;

  constructor(appId: string, apiKey: string) {
    this.widget = new ZkMeWidget({
      appId,
      apiKey,
      mode: 'production', // or 'sandbox'
    });
  }

  /**
   * Generate zero-knowledge proof for KYC verification
   */
  async generateKYCProof(userData: {
    documentType: 'passport' | 'drivers_license' | 'national_id';
    documentImage: File;
    selfieImage: File;
  }): Promise<ZKProofResult> {
    try {
      // Initialize zkMe verification
      const session = await this.widget.startVerification({
        verificationType: 'identity',
        requiredFields: ['age_over_18', 'country', 'document_validity'],
        privacyLevel: 'maximum' // Generate ZK proof without storing PII
      });

      // Upload documents (encrypted)
      await session.uploadDocument(userData.documentType, userData.documentImage);
      await session.uploadSelfie(userData.selfieImage);

      // Generate zero-knowledge proof
      const result = await session.generateProof({
        proveAgeOver18: true,
        proveCountryMembership: ['US', 'CA', 'EU'], // Allowed countries
        proveDocumentValidity: true,
        includeUniqueId: true // For preventing double-spending
      });

      return {
        proof: result.zkProof,
        publicSignals: result.publicSignals,
        verificationKey: result.verificationKey
      };
    } catch (error) {
      throw new Error(`ZK proof generation failed: ${error.message}`);
    }
  }
}
```

#### Proof Verification (Smart Contract)

```rust
use anchor_lang::prelude::*;
use groth16::{Proof, VerifyingKey, verify_proof};

#[derive(Accounts)]
pub struct VerifyZKProof<'info> {
    #[account(mut)]
    pub user_account: Account<'info, UserAccount>,
    pub user: Signer<'info>,
}

#[account]
pub struct UserAccount {
    pub owner: Pubkey,
    pub kyc_verified: bool,
    pub kyc_proof_hash: [u8; 32],
    pub verification_timestamp: i64,
    pub unique_id_hash: [u8; 32], // Prevents double verification
}

impl<'info> VerifyZKProof<'info> {
    pub fn verify_kyc_proof(
        ctx: Context<VerifyZKProof>,
        proof_data: Vec<u8>,
        public_signals: Vec<u8>,
        verifying_key: Vec<u8>,
    ) -> Result<()> {
        let user_account = &mut ctx.accounts.user_account;
        
        // Deserialize proof components
        let proof = Proof::deserialize(&proof_data)
            .map_err(|_| ErrorCode::InvalidProofFormat)?;
        
        let vk = VerifyingKey::deserialize(&verifying_key)
            .map_err(|_| ErrorCode::InvalidVerifyingKey)?;
        
        // Verify zero-knowledge proof
        let is_valid = verify_proof(&vk, &proof, &public_signals)
            .map_err(|_| ErrorCode::ProofVerificationFailed)?;
        
        require!(is_valid, ErrorCode::InvalidProof);
        
        // Extract public signals (age_over_18, country_valid, document_valid, unique_id)
        require!(public_signals.len() >= 4, ErrorCode::InsufficientPublicSignals);
        
        let age_over_18 = public_signals[0] == 1;
        let country_valid = public_signals[1] == 1;
        let document_valid = public_signals[2] == 1;
        let unique_id = &public_signals[3..35]; // 32-byte unique ID
        
        // Verify all requirements met
        require!(age_over_18 && country_valid && document_valid, ErrorCode::KYCRequirementsNotMet);
        
        // Check for duplicate verification
        let unique_id_hash = solana_program::keccak::hash(unique_id).to_bytes();
        require!(
            user_account.unique_id_hash != unique_id_hash,
            ErrorCode::DuplicateKYCVerification
        );
        
        // Update user account
        user_account.kyc_verified = true;
        user_account.kyc_proof_hash = solana_program::keccak::hash(&proof_data).to_bytes();
        user_account.verification_timestamp = Clock::get()?.unix_timestamp;
        user_account.unique_id_hash = unique_id_hash;
        
        msg!("KYC verification successful for user: {}", user_account.owner);
        Ok(())
    }
}
```

## Merkle Tree Proofs

For efficient evidence storage and verification, AetherLock uses Merkle trees to prove inclusion without revealing all data.

```typescript
import { MerkleTree } from 'merkletreejs';
import { keccak256 } from 'ethers/lib/utils';

class EvidenceMerkleTree {
  private tree: MerkleTree;
  private leaves: string[];

  constructor(evidenceHashes: string[]) {
    this.leaves = evidenceHashes.map(hash => keccak256(hash));
    this.tree = new MerkleTree(this.leaves, keccak256, { sortPairs: true });
  }

  /**
   * Generate Merkle proof for specific evidence
   */
  generateProof(evidenceHash: string): {
    proof: string[];
    root: string;
    leaf: string;
  } {
    const leaf = keccak256(evidenceHash);
    const proof = this.tree.getHexProof(leaf);
    const root = this.tree.getHexRoot();

    return { proof, root, leaf };
  }

  /**
   * Verify Merkle proof
   */
  static verifyProof(
    proof: string[],
    leaf: string,
    root: string
  ): boolean {
    return MerkleTree.verify(proof, leaf, root, keccak256, { sortPairs: true });
  }

  getRoot(): string {
    return this.tree.getHexRoot();
  }
}

// Usage example
const evidenceHashes = [
  'QmX1Y2Z3...', // IPFS hash 1
  'QmA4B5C6...', // IPFS hash 2
  'QmD7E8F9...', // IPFS hash 3
];

const merkleTree = new EvidenceMerkleTree(evidenceHashes);
const proof = merkleTree.generateProof('QmX1Y2Z3...');

console.log('Merkle Root:', proof.root);
console.log('Proof:', proof.proof);
```

## Digital Signature Best Practices

### Key Generation

```typescript
import { Keypair } from '@solana/web3.js';
import { randomBytes } from 'crypto';

class SecureKeyGenerator {
  /**
   * Generate cryptographically secure Ed25519 keypair
   */
  static generateSecureKeypair(): {
    keypair: Keypair;
    mnemonic?: string;
  } {
    // Use secure random number generator
    const seed = randomBytes(32);
    const keypair = Keypair.fromSeed(seed);

    return { keypair };
  }

  /**
   * Derive keypair from mnemonic (for recovery)
   */
  static fromMnemonic(mnemonic: string, derivationPath?: string): Keypair {
    // Implementation would use BIP39/BIP44 derivation
    // This is a simplified example
    const seed = this.mnemonicToSeed(mnemonic, derivationPath);
    return Keypair.fromSeed(seed);
  }

  private static mnemonicToSeed(mnemonic: string, path?: string): Uint8Array {
    // Implement BIP39 mnemonic to seed conversion
    // Return 32-byte seed
    throw new Error('Implement BIP39 derivation');
  }
}
```

### Signature Validation

```rust
use ed25519_dalek::{PublicKey, Signature, Verifier};
use anchor_lang::prelude::*;

pub fn validate_signature(
    message: &[u8],
    signature_bytes: &[u8; 64],
    public_key_bytes: &[u8; 32],
) -> Result<()> {
    // Parse public key
    let public_key = PublicKey::from_bytes(public_key_bytes)
        .map_err(|_| ErrorCode::InvalidPublicKey)?;
    
    // Parse signature
    let signature = Signature::from_bytes(signature_bytes)
        .map_err(|_| ErrorCode::InvalidSignature)?;
    
    // Verify signature
    public_key
        .verify(message, &signature)
        .map_err(|_| ErrorCode::SignatureVerificationFailed)?;
    
    Ok(())
}
```

## Security Considerations

### Signature Malleability

Ed25519 signatures are not malleable, but additional checks ensure security:

```rust
pub fn check_signature_uniqueness(
    signature: &[u8; 64],
    used_signatures: &mut Vec<[u8; 64]>,
) -> Result<()> {
    // Check if signature was already used (replay protection)
    require!(
        !used_signatures.contains(signature),
        ErrorCode::SignatureAlreadyUsed
    );
    
    used_signatures.push(*signature);
    Ok(())
}
```

### Key Rotation

```typescript
class KeyRotationManager {
  private currentKey: Keypair;
  private previousKeys: Keypair[];
  private rotationInterval: number;

  constructor(rotationIntervalHours: number = 24) {
    this.currentKey = Keypair.generate();
    this.previousKeys = [];
    this.rotationInterval = rotationIntervalHours * 60 * 60 * 1000;
  }

  /**
   * Rotate signing key
   */
  rotateKey(): void {
    this.previousKeys.push(this.currentKey);
    this.currentKey = Keypair.generate();
    
    // Keep only last 3 keys for verification
    if (this.previousKeys.length > 3) {
      this.previousKeys.shift();
    }
  }

  /**
   * Verify signature with current or previous keys
   */
  verifyWithRotation(message: Uint8Array, signature: Uint8Array): boolean {
    // Try current key first
    if (this.verifySignature(message, signature, this.currentKey.publicKey)) {
      return true;
    }

    // Try previous keys
    for (const key of this.previousKeys) {
      if (this.verifySignature(message, signature, key.publicKey)) {
        return true;
      }
    }

    return false;
  }

  private verifySignature(
    message: Uint8Array,
    signature: Uint8Array,
    publicKey: any
  ): boolean {
    // Implementation depends on signature library
    return false;
  }
}
```

## Proof-of-Task Verification (PoTV) Flow

AetherLock's novel Proof-of-Task Verification (PoTV) consensus mechanism combines AI analysis, zero-knowledge proofs, decentralized oracles, and smart contract validation to prove human work completion. This section documents the complete cryptographic flow and security properties.

### PoTV Overview

**Consensus Analogy**:
- **Proof-of-Work (PoW)**: Proves math (miners solve computational puzzles)
- **Proof-of-Stake (PoS)**: Proves money (validators lock capital)
- **Proof-of-Task Verification (PoTV)**: Proves human work (AI + ZK + Oracle verify task completion)

PoTV was developed by AetherLock Labs as the first consensus mechanism specifically designed for verifying the quality of human task completion in decentralized freelancing systems.

### Complete PoTV Cryptographic Flow

```mermaid
sequenceDiagram
    participant F as Freelancer
    participant AI as Arcanum.ai
    participant ZK as zkMe SDK
    participant O as Chainlink Oracle
    participant SC as Smart Contract

    F->>AI: Submit evidence + task requirements
    AI->>AI: Analyze task completion
    AI->>AI: Sign result with Ed25519
    AI->>ZK: Return signed verification result
    
    ZK->>ZK: Generate ZK proof of AI verification
    ZK->>O: Submit ZK proof + public signals
    
    O->>O: Validate ZK proof (multi-node consensus)
    O->>O: Sign oracle attestation
    O->>SC: Submit on-chain transaction
    
    SC->>SC: Verify oracle signatures
    SC->>SC: Validate PoTV chain integrity
    SC->>SC: Execute fund release or dispute
    SC->>F: Emit verification event
```

### Step 1: AI Analysis and Cryptographic Signing

**Arcanum.ai** analyzes submitted evidence against task requirements and cryptographically signs the result.

```typescript
import { Keypair } from '@solana/web3.js';
import { sign } from 'tweetnacl';
import { encode as bs58Encode } from 'bs58';
import { createHmac } from 'crypto';

interface TaskEvidence {
  escrowId: string;
  taskDescription: string;
  evidenceFiles: string[]; // IPFS hashes
  submittedAt: number;
}

interface AIVerificationResult {
  escrowId: string;
  confidence: number; // 0.0 to 1.0
  decision: 'approved' | 'rejected' | 'review';
  reasoning: string;
  timestamp: number;
  evidenceHash: string;
}

class ArcanumAIVerifier {
  private signingKeypair: Keypair;
  private apiKey: string;
  private endpoint: string;

  constructor(apiKey: string, endpoint: string, signingKey: Uint8Array) {
    this.apiKey = apiKey;
    this.endpoint = endpoint;
    this.signingKeypair = Keypair.fromSecretKey(signingKey);
  }

  /**
   * Step 1: Analyze evidence and generate cryptographically signed result
   */
  async verifyTaskCompletion(evidence: TaskEvidence): Promise<{
    result: AIVerificationResult;
    signature: string;
    publicKey: string;
  }> {
    // 1. Call Arcanum.ai API for analysis
    const analysisResult = await this.callArcanumAPI(evidence);
    
    // 2. Create verification result
    const result: AIVerificationResult = {
      escrowId: evidence.escrowId,
      confidence: analysisResult.confidence,
      decision: analysisResult.decision,
      reasoning: analysisResult.reasoning,
      timestamp: Date.now(),
      evidenceHash: this.hashEvidence(evidence.evidenceFiles)
    };
    
    // 3. Create canonical message for signing
    const message = this.createCanonicalMessage(result);
    const messageBytes = new TextEncoder().encode(message);
    
    // 4. Generate Ed25519 signature
    const signature = sign.detached(messageBytes, this.signingKeypair.secretKey);
    
    // 5. Create HMAC for additional integrity check
    const hmac = createHmac('sha256', this.apiKey)
      .update(message)
      .digest('hex');
    
    return {
      result,
      signature: bs58Encode(signature),
      publicKey: this.signingKeypair.publicKey.toBase58()
    };
  }

  /**
   * Call Arcanum.ai API for task analysis
   */
  private async callArcanumAPI(evidence: TaskEvidence): Promise<any> {
    const response = await fetch(`${this.endpoint}/analyze`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        taskDescription: evidence.taskDescription,
        evidenceFiles: evidence.evidenceFiles,
        escrowId: evidence.escrowId
      })
    });

    if (!response.ok) {
      throw new Error(`Arcanum.ai API error: ${response.statusText}`);
    }

    return await response.json();
  }

  /**
   * Create deterministic message format for signing
   */
  private createCanonicalMessage(result: AIVerificationResult): string {
    return [
      `escrow:${result.escrowId}`,
      `confidence:${result.confidence.toFixed(6)}`,
      `decision:${result.decision}`,
      `timestamp:${result.timestamp}`,
      `evidence:${result.evidenceHash}`
    ].join('|');
  }

  /**
   * Hash evidence files for integrity
   */
  private hashEvidence(evidenceFiles: string[]): string {
    const combined = evidenceFiles.sort().join('|');
    return createHmac('sha256', 'evidence-integrity')
      .update(combined)
      .digest('hex');
  }
}
```

**Security Properties**:
- **Authenticity**: Ed25519 signature proves result came from authorized AI service
- **Integrity**: Any tampering with result invalidates signature
- **Non-repudiation**: AI service cannot deny generating the result
- **Timestamp binding**: Result includes timestamp to prevent replay attacks

### Step 2: Zero-Knowledge Proof Generation

**zkMe SDK** generates a ZK proof that AI verification occurred without revealing the evidence content.

```typescript
import { ZKProofGenerator } from '@zkme/sdk';

interface ZKProofInput {
  aiResult: AIVerificationResult;
  aiSignature: string;
  aiPublicKey: string;
  evidenceHash: string;
}

interface ZKProofOutput {
  proof: string;
  publicSignals: string[];
  verificationKey: string;
}

class PoTVZKProofGenerator {
  private zkGenerator: ZKProofGenerator;

  constructor(zkmeConfig: { appId: string; apiKey: string }) {
    this.zkGenerator = new ZKProofGenerator(zkmeConfig);
  }

  /**
   * Step 2: Generate zero-knowledge proof of AI verification
   */
  async generatePoTVProof(input: ZKProofInput): Promise<ZKProofOutput> {
    // Define what we're proving (public signals):
    // 1. AI verification occurred (boolean)
    // 2. Confidence threshold met (boolean)
    // 3. Timestamp is recent (boolean)
    // 4. Signature is valid (boolean)
    
    // What we're NOT revealing (private inputs):
    // - Actual evidence content
    // - Detailed AI reasoning
    // - Specific confidence score (only threshold)
    
    const circuit = {
      // Public signals (visible on-chain)
      publicSignals: {
        escrowId: input.aiResult.escrowId,
        verificationOccurred: 1, // boolean as integer
        confidenceThresholdMet: input.aiResult.confidence >= 0.8 ? 1 : 0,
        timestampValid: this.isTimestampRecent(input.aiResult.timestamp) ? 1 : 0,
        signatureValid: 1, // Verified off-chain before proof generation
        decision: this.decisionToInt(input.aiResult.decision)
      },
      
      // Private inputs (hidden)
      privateInputs: {
        actualConfidence: input.aiResult.confidence,
        evidenceHash: input.evidenceHash,
        aiReasoning: input.aiResult.reasoning,
        signature: input.aiSignature
      }
    };

    // Generate ZK proof using Groth16 or PLONK
    const proof = await this.zkGenerator.generateProof(circuit);

    return {
      proof: proof.proof,
      publicSignals: Object.values(circuit.publicSignals).map(String),
      verificationKey: proof.verificationKey
    };
  }

  private isTimestampRecent(timestamp: number): boolean {
    const now = Date.now();
    const maxAge = 5 * 60 * 1000; // 5 minutes
    return (now - timestamp) < maxAge;
  }

  private decisionToInt(decision: string): number {
    const mapping = { 'approved': 1, 'rejected': 2, 'review': 3 };
    return mapping[decision] || 0;
  }
}
```

**Security Properties**:
- **Privacy**: Evidence content remains private, only verification result is proven
- **Completeness**: Valid AI verification always produces valid proof
- **Soundness**: Invalid AI verification cannot produce valid proof
- **Zero-knowledge**: Proof reveals nothing beyond public signals

### Step 3: Chainlink Oracle Validation

**Chainlink Functions** validates the ZK proof through decentralized oracle network consensus.

```typescript
interface ChainlinkOracleRequest {
  escrowId: string;
  zkProof: string;
  publicSignals: string[];
  verificationKey: string;
}

interface ChainlinkOracleResponse {
  requestId: string;
  isValid: boolean;
  oracleSignatures: string[];
  consensusReached: boolean;
  timestamp: number;
}

class ChainlinkPoTVOracle {
  private chainlinkEndpoint: string;
  private oracleNodes: string[];

  constructor(endpoint: string, nodes: string[]) {
    this.chainlinkEndpoint = endpoint;
    this.oracleNodes = nodes;
  }

  /**
   * Step 3: Submit ZK proof to Chainlink oracle network
   */
  async submitProofToOracles(request: ChainlinkOracleRequest): Promise<ChainlinkOracleResponse> {
    // 1. Submit to multiple oracle nodes
    const validationPromises = this.oracleNodes.map(node => 
      this.submitToSingleOracle(node, request)
    );

    // 2. Wait for consensus (majority agreement)
    const results = await Promise.all(validationPromises);
    const validCount = results.filter(r => r.isValid).length;
    const consensusReached = validCount > (this.oracleNodes.length / 2);

    // 3. Collect oracle signatures
    const oracleSignatures = results
      .filter(r => r.isValid)
      .map(r => r.signature);

    return {
      requestId: this.generateRequestId(request),
      isValid: consensusReached,
      oracleSignatures,
      consensusReached,
      timestamp: Date.now()
    };
  }

  /**
   * Submit to single oracle node for validation
   */
  private async submitToSingleOracle(
    nodeUrl: string,
    request: ChainlinkOracleRequest
  ): Promise<{ isValid: boolean; signature: string }> {
    const response = await fetch(`${nodeUrl}/validate-zk-proof`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request)
    });

    const result = await response.json();
    return {
      isValid: result.isValid,
      signature: result.oracleSignature
    };
  }

  private generateRequestId(request: ChainlinkOracleRequest): string {
    return createHmac('sha256', 'chainlink-request')
      .update(JSON.stringify(request))
      .digest('hex');
  }
}
```

**Security Properties**:
- **Decentralization**: Multiple independent oracle nodes validate proof
- **Consensus**: Majority agreement required before on-chain submission
- **Fault tolerance**: System continues if minority of nodes fail
- **Sybil resistance**: Oracle nodes are economically incentivized to be honest

### Step 4: Smart Contract Validation

**Solana Anchor Program** validates the complete PoTV chain and executes fund release.

```rust
use anchor_lang::prelude::*;
use groth16::{Proof, VerifyingKey, verify_proof};

#[derive(Accounts)]
pub struct ValidatePoTV<'info> {
    #[account(mut)]
    pub escrow: Account<'info, EscrowAccount>,
    #[account(mut)]
    pub freelancer: Signer<'info>,
    pub chainlink_oracle: Signer<'info>,
}

#[account]
pub struct EscrowAccount {
    pub id: String,
    pub client: Pubkey,
    pub freelancer: Pubkey,
    pub amount: u64,
    pub ai_public_key: [u8; 32],
    pub potv_validated: bool,
    pub validation_timestamp: i64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct PoTVValidation {
    pub zk_proof: Vec<u8>,
    pub public_signals: Vec<u8>,
    pub oracle_signatures: Vec<[u8; 64]>,
    pub timestamp: i64,
}

impl<'info> ValidatePoTV<'info> {
    /**
     * Step 4: Validate complete PoTV chain on-chain
     */
    pub fn validate_potv_chain(
        ctx: Context<ValidatePoTV>,
        validation: PoTVValidation,
    ) -> Result<()> {
        let escrow = &mut ctx.accounts.escrow;
        
        // 1. Verify timestamp is recent (within 10 minutes)
        let current_time = Clock::get()?.unix_timestamp;
        require!(
            current_time - validation.timestamp < 600,
            ErrorCode::TimestampTooOld
        );
        
        // 2. Verify ZK proof
        let proof = Proof::deserialize(&validation.zk_proof)
            .map_err(|_| ErrorCode::InvalidZKProof)?;
        
        let vk = Self::get_verification_key()?;
        
        let is_valid = verify_proof(&vk, &proof, &validation.public_signals)
            .map_err(|_| ErrorCode::ZKProofVerificationFailed)?;
        
        require!(is_valid, ErrorCode::InvalidZKProof);
        
        // 3. Verify oracle consensus (majority of signatures)
        let required_signatures = (validation.oracle_signatures.len() / 2) + 1;
        require!(
            validation.oracle_signatures.len() >= required_signatures,
            ErrorCode::InsufficientOracleConsensus
        );
        
        // 4. Verify each oracle signature
        for oracle_sig in &validation.oracle_signatures {
            Self::verify_oracle_signature(
                &validation.zk_proof,
                oracle_sig,
                &ctx.accounts.chainlink_oracle.key()
            )?;
        }
        
        // 5. Extract decision from public signals
        let decision = validation.public_signals[5]; // decision field
        require!(decision == 1, ErrorCode::TaskNotApproved); // 1 = approved
        
        // 6. Mark PoTV as validated
        escrow.potv_validated = true;
        escrow.validation_timestamp = current_time;
        
        // 7. Release funds to freelancer
        Self::release_funds(escrow, &ctx.accounts.freelancer)?;
        
        msg!("PoTV validation complete. Funds released to freelancer.");
        Ok(())
    }
    
    fn verify_oracle_signature(
        proof_data: &[u8],
        signature: &[u8; 64],
        oracle_pubkey: &Pubkey,
    ) -> Result<()> {
        // Verify oracle's Ed25519 signature on proof data
        let message = solana_program::keccak::hash(proof_data);
        
        // Implementation would verify signature matches oracle's public key
        // Simplified for example
        Ok(())
    }
    
    fn get_verification_key() -> Result<VerifyingKey> {
        // Load verification key for ZK proof circuit
        // In production, this would be stored in program data account
        todo!("Load verification key from program data")
    }
    
    fn release_funds(escrow: &EscrowAccount, freelancer: &Signer) -> Result<()> {
        // Transfer funds from escrow to freelancer
        // Implementation depends on token program
        msg!("Releasing {} lamports to {}", escrow.amount, freelancer.key());
        Ok(())
    }
}

#[error_code]
pub enum ErrorCode {
    #[msg("Timestamp is too old")]
    TimestampTooOld,
    #[msg("Invalid ZK proof format")]
    InvalidZKProof,
    #[msg("ZK proof verification failed")]
    ZKProofVerificationFailed,
    #[msg("Insufficient oracle consensus")]
    InsufficientOracleConsensus,
    #[msg("Task was not approved")]
    TaskNotApproved,
}
```

**Security Properties**:
- **Immutability**: Validation result permanently recorded on-chain
- **Transparency**: All validation steps auditable via blockchain
- **Atomicity**: Fund release happens atomically with validation
- **Finality**: Once validated, result cannot be reversed (except via dispute)

## PoTV Security Analysis

### Attack Resistance

| Attack Vector | Description | Mitigation |
|---------------|-------------|------------|
| **AI Result Manipulation** | Attacker attempts to forge or modify AI verification results | Ed25519 signatures prevent tampering; results cryptographically bound to authorized AI service |
| **Evidence Replay** | Attacker reuses old evidence for new tasks | Timestamp validation and unique escrow IDs prevent replay; each verification includes fresh timestamp |
| **Oracle Collusion** | Malicious oracles attempt to approve invalid verifications | Chainlink's decentralized network requires majority consensus; economic incentives align with honest behavior; slashing for dishonest oracles |
| **ZK Proof Forgery** | Attacker attempts to create fake proof of verification | zkMe's cryptographic primitives (Groth16/PLONK) make forgery computationally infeasible (128-bit security) |
| **Provider Downtime** | Primary AI provider becomes unavailable | Fallback chain (Arcanum.ai → OpenAI → Claude → Gemini) ensures 99.9% availability |
| **Smart Contract Exploit** | Attacker finds vulnerability in on-chain validation logic | Formal verification, multiple security audits, time-locked upgrades, and bug bounty program |
| **Man-in-the-Middle** | Attacker intercepts communication between components | TLS encryption for all API calls; signature verification at each step |
| **Sybil Attack on Oracles** | Attacker creates multiple fake oracle nodes | Chainlink's reputation system and staking requirements prevent Sybil attacks |

### Failure Modes

| Failure Type | Probability | Impact | Recovery Mechanism |
|--------------|-------------|--------|-------------------|
| **AI Provider Failure** | Low (0.1%) | Medium | Automatic fallback to OpenAI → Claude → Gemini; verification continues with <5s delay |
| **ZK Proof Generation Failure** | Very Low (0.01%) | Medium | Retry with exponential backoff (3 attempts); escalate to manual review after threshold |
| **Oracle Network Failure** | Very Low (0.01%) | High | Transaction queued until network recovers; timeout triggers dispute resolution after 24h |
| **Smart Contract Failure** | Extremely Low (<0.001%) | Critical | Funds remain locked in escrow; emergency multi-sig withdrawal after 7-day timeout |
| **Complete System Failure** | Extremely Low (<0.001%) | Critical | Multi-signature emergency recovery allows fund return to original parties; requires 3/5 admin signatures |
| **Invalid ZK Proof** | Low (1-2%) | Low | Automatic retry with fresh proof generation; if persistent, escalate to manual review |
| **Oracle Consensus Failure** | Very Low (0.05%) | Medium | Retry with different oracle node set; if persistent, trigger dispute resolution |

### Cryptographic Guarantees

**End-to-End Security Properties**:

1. **Authenticity**: Every component in PoTV chain is cryptographically authenticated
   - AI results signed with Ed25519
   - ZK proofs use Groth16/PLONK with 128-bit security
   - Oracle attestations signed by Chainlink nodes
   - Smart contract validates all signatures

2. **Integrity**: Any tampering at any step invalidates the entire chain
   - Hash chains link each step
   - Signature verification at each transition
   - On-chain validation checks complete chain

3. **Privacy**: Evidence content never exposed on-chain
   - ZK proofs reveal only verification outcome
   - Evidence stored off-chain (IPFS)
   - Only hashes and public signals on-chain

4. **Non-repudiation**: No party can deny their actions
   - All signatures permanently recorded
   - Blockchain provides immutable audit trail
   - Timestamps prevent backdating

5. **Availability**: System remains operational despite component failures
   - AI provider fallback chain
   - Decentralized oracle network
   - Redundant evidence storage

## Audit Checklist

### Cryptographic Implementation Review

- [ ] **Ed25519 Implementation**
  - [ ] Uses secure random number generation
  - [ ] Proper key derivation from entropy
  - [ ] Signature verification includes all edge cases
  - [ ] No signature malleability vulnerabilities

- [ ] **Zero-Knowledge Proofs**
  - [ ] Trusted setup parameters verified
  - [ ] Circuit constraints properly implemented
  - [ ] Public signals validation complete
  - [ ] No information leakage in proof generation

- [ ] **Hash Functions**
  - [ ] Uses SHA-256 or Keccak-256 consistently
  - [ ] Proper salt usage for password hashing
  - [ ] Merkle tree implementation secure
  - [ ] No hash collision vulnerabilities

- [ ] **Key Management**
  - [ ] Private keys never logged or exposed
  - [ ] Secure key storage mechanisms
  - [ ] Key rotation procedures implemented
  - [ ] Recovery mechanisms secure

### PoTV-Specific Security Checks

- [ ] **AI Result Authentication**
  - [ ] All AI results cryptographically signed
  - [ ] Signature verification before ZK proof generation
  - [ ] Timestamp validation prevents replay attacks
  - [ ] HMAC provides additional integrity check

- [ ] **Zero-Knowledge Proof Validation**
  - [ ] ZK circuit correctly implements verification logic
  - [ ] Public signals properly constrained
  - [ ] Private inputs never leaked
  - [ ] Proof verification on-chain is correct

- [ ] **Chainlink Oracle Integration**
  - [ ] Multiple oracle nodes validate independently
  - [ ] Consensus mechanism requires majority
  - [ ] Oracle signatures verified on-chain
  - [ ] Economic incentives align with honest behavior

- [ ] **Smart Contract Validation**
  - [ ] Complete PoTV chain validated atomically
  - [ ] Timestamp freshness checked
  - [ ] All signatures verified
  - [ ] Fund release only after full validation

### Common Vulnerabilities

- [ ] **Replay Attacks**: Nonces and timestamps used
- [ ] **Side-Channel Attacks**: Constant-time implementations
- [ ] **Weak Randomness**: Cryptographically secure RNG
- [ ] **Key Reuse**: Unique keys for different purposes
- [ ] **Signature Forgery**: Proper signature validation
- [ ] **Oracle Manipulation**: Decentralized consensus required
- [ ] **ZK Proof Malleability**: Proof uniqueness enforced
- [ ] **Timestamp Manipulation**: Clock drift tolerance configured

This comprehensive cryptographic foundation, combined with the novel PoTV consensus mechanism, ensures AetherLock maintains the highest security standards while enabling trustless verification of human task completion.