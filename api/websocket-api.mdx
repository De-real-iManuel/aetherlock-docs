# WebSocket API

## Overview

The AetherLock WebSocket API provides real-time updates for escrow state changes, AI verification results, cross-chain transaction confirmations, and system notifications. This enables responsive user interfaces and immediate notification of important events.

**WebSocket Endpoint**: `wss://ws.aetherlock.io/v1`

## Implementation Status

> **Current Deployment**: PARTIALLY IMPLEMENTED - Core events available, some events planned for future releases

| Event Category | Status | Notes |
|----------------|--------|-------|
| Escrow Events | âœ… IMPLEMENTED | Created, funded, status changes |
| Verification Events | âœ… IMPLEMENTED | Started, progress, completed |
| Cross-Chain Events | âš ï¸ TESTNET ONLY | Available on testnet networks |
| KYC Events | ðŸ”„ IN PROGRESS | Mock flow available |
| System Events | âœ… IMPLEMENTED | Maintenance, network status |
| AI Provider Status | âœ… IMPLEMENTED | Arcanum.ai monitoring |

## Connection Establishment

### Authentication

WebSocket connections require JWT authentication obtained through the REST API.

```typescript
const ws = new WebSocket('wss://ws.aetherlock.io/v1');

ws.onopen = () => {
  // Send authentication message
  ws.send(JSON.stringify({
    type: 'auth',
    token: 'YOUR_JWT_TOKEN'
  }));
};

ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  
  if (message.type === 'auth_success') {
    console.log('WebSocket authenticated successfully');
    // Start subscribing to events
    subscribeToEvents();
  } else if (message.type === 'auth_error') {
    console.error('Authentication failed:', message.error);
  }
};
```

### Connection States

| State | Description |
|-------|-------------|
| `connecting` | Initial connection attempt |
| `authenticated` | Successfully authenticated |
| `subscribed` | Subscribed to one or more event types |
| `error` | Connection or authentication error |
| `disconnected` | Connection closed |

## Subscription Management

### Subscribe to Events

```typescript
function subscribeToEvents() {
  // Subscribe to escrow events for specific escrows
  ws.send(JSON.stringify({
    type: 'subscribe',
    events: ['escrow.status_changed', 'verification.completed'],
    filters: {
      escrowIds: ['escrow_abc123', 'escrow_def456'],
      userAddress: '9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM'
    }
  }));
  
  // Subscribe to global events
  ws.send(JSON.stringify({
    type: 'subscribe',
    events: ['system.maintenance', 'network.status'],
    global: true
  }));
}
```

### Unsubscribe from Events

```typescript
function unsubscribeFromEvents() {
  ws.send(JSON.stringify({
    type: 'unsubscribe',
    events: ['escrow.status_changed'],
    filters: {
      escrowIds: ['escrow_abc123']
    }
  }));
}
```

### Subscription Response

```json
{
  "type": "subscription_success",
  "subscriptionId": "sub_123456",
  "events": ["escrow.status_changed", "verification.completed"],
  "filters": {
    "escrowIds": ["escrow_abc123"],
    "userAddress": "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM"
  },
  "timestamp": "2024-01-10T15:30:00Z"
}
```

## Event Types

### Escrow Events

#### escrow.created

Emitted when a new escrow is created.

```json
{
  "type": "escrow.created",
  "timestamp": "2024-01-10T15:30:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "clientAddress": "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM",
    "freelancerAddress": "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU",
    "amount": "1000000000",
    "currency": "SOL",
    "chainId": "solana",
    "title": "Website Design Project",
    "deadline": "2024-01-15T23:59:59Z",
    "contractAddress": "CONTRACT_ADDRESS",
    "transactionHash": "CREATION_TX_HASH"
  }
}
```

#### escrow.funded

Emitted when an escrow receives funding.

```json
{
  "type": "escrow.funded",
  "timestamp": "2024-01-10T15:35:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "amount": "1000000000",
    "transactionHash": "FUNDING_TX_HASH",
    "blockNumber": 123456789,
    "confirmations": 32,
    "status": "funded"
  }
}
```

#### escrow.status_changed

Emitted when escrow status changes.

```json
{
  "type": "escrow.status_changed",
  "timestamp": "2024-01-10T16:00:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "previousStatus": "funded",
    "newStatus": "evidence_submitted",
    "changedBy": "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU",
    "transactionHash": "STATUS_CHANGE_TX_HASH"
  }
}
```

#### escrow.evidence_submitted

Emitted when freelancer submits evidence.

```json
{
  "type": "escrow.evidence_submitted",
  "timestamp": "2024-01-10T16:00:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "freelancerAddress": "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU",
    "evidenceId": "evidence_xyz789",
    "ipfsHash": "QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG",
    "fileCount": 3,
    "totalSize": 5242880,
    "description": "Completed website with all requirements"
  }
}
```

#### escrow.released

Emitted when funds are released to freelancer.

```json
{
  "type": "escrow.released",
  "timestamp": "2024-01-10T16:30:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "freelancerAddress": "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU",
    "amount": "900000000",
    "protocolFee": "100000000",
    "transactionHash": "RELEASE_TX_HASH",
    "settlementChain": "somnia"
  }
}
```

#### escrow.disputed

Emitted when a dispute is initiated (NOT YET IMPLEMENTED - Planned for production).

```json
{
  "type": "escrow.disputed",
  "timestamp": "2024-01-10T17:00:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "disputeId": "dispute_ghi789",
    "initiatedBy": "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM",
    "reason": "AI verification incorrect",
    "description": "The AI missed several requirements that were clearly implemented",
    "estimatedResolution": "2024-01-12T17:00:00Z"
  }
}
```

### Verification Events

#### verification.started

Emitted when AI verification begins.

```json
{
  "type": "verification.started",
  "timestamp": "2024-01-10T16:01:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "verificationId": "verification_def456",
    "aiProvider": "arcanum-ai",
    "model": "arcanum-pro",
    "estimatedCompletion": "2024-01-10T16:03:00Z"
  }
}
```

#### verification.progress

Emitted during AI verification process.

```json
{
  "type": "verification.progress",
  "timestamp": "2024-01-10T16:02:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "verificationId": "verification_def456",
    "progress": 65,
    "currentStep": "analyzing_code_quality",
    "stepsCompleted": ["downloading_evidence", "extracting_files", "parsing_requirements"],
    "stepsRemaining": ["checking_deliverables", "generating_report"]
  }
}
```

#### verification.completed

Emitted when AI verification is complete.

```json
{
  "type": "verification.completed",
  "timestamp": "2024-01-10T16:03:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "verificationId": "verification_def456",
    "result": "approved",
    "confidence": 0.94,
    "reasoning": "All requirements met. Code quality is excellent, responsive design implemented correctly.",
    "criteria": [
      {
        "requirement": "Responsive design",
        "status": "passed",
        "confidence": 0.96
      },
      {
        "requirement": "Mobile optimization",
        "status": "passed",
        "confidence": 0.92
      }
    ],
    "processingTime": 2.3,
    "aiSignature": "AI_RESULT_ED25519_SIGNATURE"
  }
}
```

#### verification.failed

Emitted when AI verification encounters an error.

```json
{
  "type": "verification.failed",
  "timestamp": "2024-01-10T16:03:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "verificationId": "verification_def456",
    "error": "EVIDENCE_CORRUPTED",
    "message": "Unable to extract files from IPFS hash",
    "retryable": true,
    "nextRetryAt": "2024-01-10T16:08:00Z",
    "fallbackProvider": "openai"
  }
}
```

### Cross-Chain Events

> **Implementation Status**: TESTNET ONLY - Cross-chain events available on testnet networks

#### crosschain.message_sent

Emitted when a cross-chain message is sent.

```json
{
  "type": "crosschain.message_sent",
  "timestamp": "2024-01-10T15:35:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "messageId": "msg_123456",
    "fromChain": "solana",
    "toChain": "zetachain",
    "messageType": "ESCROW_CREATED",
    "transactionHash": "SOURCE_TX_HASH",
    "estimatedArrival": "2024-01-10T15:37:00Z"
  }
}
```

#### crosschain.message_received

Emitted when a cross-chain message is received.

```json
{
  "type": "crosschain.message_received",
  "timestamp": "2024-01-10T15:37:00Z",
  "data": {
    "escrowId": "escrow_abc123",
    "messageId": "msg_123456",
    "fromChain": "solana",
    "toChain": "zetachain",
    "messageType": "ESCROW_CREATED",
    "transactionHash": "DESTINATION_TX_HASH",
    "processed": true
  }
}
```

#### crosschain.bridge_initiated

Emitted when cross-chain asset bridging starts.

```json
{
  "type": "crosschain.bridge_initiated",
  "timestamp": "2024-01-10T15:40:00Z",
  "data": {
    "bridgeId": "bridge_jkl012",
    "escrowId": "escrow_abc123",
    "fromChain": "solana",
    "toChain": "somnia",
    "asset": "SOL",
    "amount": "1000000000",
    "fromTxHash": "SOURCE_BRIDGE_TX_HASH",
    "estimatedArrival": "2024-01-10T15:45:00Z"
  }
}
```

#### crosschain.bridge_completed

Emitted when cross-chain bridging completes.

```json
{
  "type": "crosschain.bridge_completed",
  "timestamp": "2024-01-10T15:43:00Z",
  "data": {
    "bridgeId": "bridge_jkl012",
    "escrowId": "escrow_abc123",
    "fromChain": "solana",
    "toChain": "somnia",
    "fromTxHash": "SOURCE_BRIDGE_TX_HASH",
    "toTxHash": "DESTINATION_BRIDGE_TX_HASH",
    "amount": "1000000000",
    "actualDuration": 180
  }
}
```

### KYC Events

> **Implementation Status**: INTEGRATION IN PROGRESS - Mock KYC flow available, zkMe SDK integration pending

#### kyc.verification_started

Emitted when KYC verification begins.

```json
{
  "type": "kyc.verification_started",
  "timestamp": "2024-01-10T14:00:00Z",
  "data": {
    "userAddress": "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM",
    "provider": "zkme",
    "verificationLevel": "basic",
    "sessionId": "zkme_session_123"
  }
}
```

#### kyc.verification_completed

Emitted when KYC verification completes.

```json
{
  "type": "kyc.verification_completed",
  "timestamp": "2024-01-10T14:15:00Z",
  "data": {
    "userAddress": "9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM",
    "provider": "zkme",
    "status": "verified",
    "verificationLevel": "basic",
    "credentialHash": "ZERO_KNOWLEDGE_CREDENTIAL_HASH",
    "expiresAt": "2025-01-10T14:15:00Z"
  }
}
```

### System Events

#### system.maintenance

Emitted for system maintenance notifications.

```json
{
  "type": "system.maintenance",
  "timestamp": "2024-01-10T12:00:00Z",
  "data": {
    "maintenanceId": "maint_789",
    "status": "scheduled",
    "startTime": "2024-01-11T02:00:00Z",
    "endTime": "2024-01-11T04:00:00Z",
    "affectedServices": ["ai-verification", "cross-chain-messaging"],
    "description": "Scheduled maintenance for Arcanum.ai service upgrades"
  }
}
```

#### ai_provider.status

Emitted for AI provider status updates.

> **Note**: Currently only Arcanum.ai is monitored. Multi-provider fallback is planned for production.

```json
{
  "type": "ai_provider.status",
  "timestamp": "2024-01-10T15:00:00Z",
  "data": {
    "provider": "arcanum-ai",
    "status": "operational",
    "latency": 1.2,
    "successRate": 0.998,
    "activeRequests": 45,
    "fallbackActive": false
  }
}
```

```json
{
  "type": "ai_provider.status",
  "timestamp": "2024-01-10T15:05:00Z",
  "data": {
    "provider": "arcanum-ai",
    "status": "degraded",
    "latency": 8.5,
    "successRate": 0.85,
    "activeRequests": 120,
    "fallbackActive": false,
    "message": "High latency detected"
  }
}
```

#### network.status

Emitted for blockchain network status updates.

```json
{
  "type": "network.status",
  "timestamp": "2024-01-10T15:00:00Z",
  "data": {
    "chainId": "solana",
    "status": "operational",
    "blockHeight": 123456789,
    "avgBlockTime": 400,
    "congestion": "low",
    "recommendedFee": "5000"
  }
}
```

## Client Implementation Examples

### JavaScript/TypeScript Client

```typescript
class AetherLockWebSocket {
  private ws: WebSocket | null = null;
  private token: string;
  private subscriptions: Map<string, Function[]> = new Map();
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  constructor(token: string) {
    this.token = token;
  }
  
  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket('wss://ws.aetherlock.io/v1');
      
      this.ws.onopen = () => {
        this.authenticate().then(resolve).catch(reject);
      };
      
      this.ws.onmessage = (event) => {
        this.handleMessage(JSON.parse(event.data));
      };
      
      this.ws.onclose = () => {
        this.handleDisconnect();
      };
      
      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        reject(error);
      };
    });
  }
  
  private async authenticate(): Promise<void> {
    return new Promise((resolve, reject) => {
      const authHandler = (message: any) => {
        if (message.type === 'auth_success') {
          this.reconnectAttempts = 0;
          resolve();
        } else if (message.type === 'auth_error') {
          reject(new Error(message.error));
        }
      };
      
      this.subscriptions.set('auth', [authHandler]);
      
      this.send({
        type: 'auth',
        token: this.token
      });
    });
  }
  
  subscribe(eventType: string, callback: Function, filters?: any): void {
    if (!this.subscriptions.has(eventType)) {
      this.subscriptions.set(eventType, []);
      
      // Send subscription message to server
      this.send({
        type: 'subscribe',
        events: [eventType],
        filters: filters
      });
    }
    
    this.subscriptions.get(eventType)!.push(callback);
  }
  
  unsubscribe(eventType: string, callback?: Function): void {
    if (!this.subscriptions.has(eventType)) return;
    
    const callbacks = this.subscriptions.get(eventType)!;
    
    if (callback) {
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    } else {
      callbacks.length = 0;
    }
    
    if (callbacks.length === 0) {
      this.subscriptions.delete(eventType);
      
      // Send unsubscribe message to server
      this.send({
        type: 'unsubscribe',
        events: [eventType]
      });
    }
  }
  
  private handleMessage(message: any): void {
    const callbacks = this.subscriptions.get(message.type) || [];
    callbacks.forEach(callback => callback(message));
  }
  
  private handleDisconnect(): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = Math.pow(2, this.reconnectAttempts) * 1000; // Exponential backoff
      
      setTimeout(() => {
        console.log(`Reconnecting... (attempt ${this.reconnectAttempts})`);
        this.connect();
      }, delay);
    } else {
      console.error('Max reconnection attempts reached');
    }
  }
  
  private send(message: any): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    }
  }
  
  disconnect(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

// Usage example
const wsClient = new AetherLockWebSocket('YOUR_JWT_TOKEN');

await wsClient.connect();

// Subscribe to escrow events
wsClient.subscribe('escrow.status_changed', (message) => {
  console.log('Escrow status changed:', message.data);
  updateUI(message.data);
}, {
  userAddress: '9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM'
});

// Subscribe to verification events
wsClient.subscribe('verification.completed', (message) => {
  console.log('Verification completed:', message.data);
  showVerificationResult(message.data);
});

// Subscribe to cross-chain events
wsClient.subscribe('crosschain.bridge_completed', (message) => {
  console.log('Bridge completed:', message.data);
  notifyBridgeCompletion(message.data);
});
```

### React Hook

```typescript
import { useEffect, useRef, useState } from 'react';

interface UseAetherLockWebSocketOptions {
  token: string;
  autoConnect?: boolean;
}

export function useAetherLockWebSocket({ token, autoConnect = true }: UseAetherLockWebSocketOptions) {
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const wsRef = useRef<AetherLockWebSocket | null>(null);
  
  useEffect(() => {
    if (autoConnect && token) {
      connect();
    }
    
    return () => {
      disconnect();
    };
  }, [token, autoConnect]);
  
  const connect = async () => {
    try {
      wsRef.current = new AetherLockWebSocket(token);
      await wsRef.current.connect();
      setIsConnected(true);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Connection failed');
      setIsConnected(false);
    }
  };
  
  const disconnect = () => {
    if (wsRef.current) {
      wsRef.current.disconnect();
      wsRef.current = null;
    }
    setIsConnected(false);
  };
  
  const subscribe = (eventType: string, callback: Function, filters?: any) => {
    if (wsRef.current) {
      wsRef.current.subscribe(eventType, callback, filters);
    }
  };
  
  const unsubscribe = (eventType: string, callback?: Function) => {
    if (wsRef.current) {
      wsRef.current.unsubscribe(eventType, callback);
    }
  };
  
  return {
    isConnected,
    error,
    connect,
    disconnect,
    subscribe,
    unsubscribe
  };
}

// Usage in React component
function EscrowDashboard() {
  const { isConnected, subscribe, unsubscribe } = useAetherLockWebSocket({
    token: 'YOUR_JWT_TOKEN'
  });
  
  const [escrows, setEscrows] = useState([]);
  
  useEffect(() => {
    if (isConnected) {
      const handleEscrowUpdate = (message: any) => {
        setEscrows(prev => 
          prev.map(escrow => 
            escrow.id === message.data.escrowId 
              ? { ...escrow, status: message.data.newStatus }
              : escrow
          )
        );
      };
      
      subscribe('escrow.status_changed', handleEscrowUpdate);
      
      return () => {
        unsubscribe('escrow.status_changed', handleEscrowUpdate);
      };
    }
  }, [isConnected, subscribe, unsubscribe]);
  
  return (
    <div>
      <div>Connection Status: {isConnected ? 'Connected' : 'Disconnected'}</div>
      {/* Render escrows */}
    </div>
  );
}
```

### Python Client

```python
import asyncio
import json
import websockets
from typing import Dict, List, Callable, Optional

class AetherLockWebSocket:
    def __init__(self, token: str):
        self.token = token
        self.ws = None
        self.subscriptions: Dict[str, List[Callable]] = {}
        self.is_connected = False
        
    async def connect(self):
        try:
            self.ws = await websockets.connect('wss://ws.aetherlock.io/v1')
            await self.authenticate()
            self.is_connected = True
            
            # Start listening for messages
            asyncio.create_task(self.listen())
            
        except Exception as e:
            print(f"Connection failed: {e}")
            raise
    
    async def authenticate(self):
        auth_message = {
            'type': 'auth',
            'token': self.token
        }
        await self.ws.send(json.dumps(auth_message))
        
        # Wait for auth response
        response = await self.ws.recv()
        message = json.loads(response)
        
        if message['type'] == 'auth_error':
            raise Exception(f"Authentication failed: {message['error']}")
    
    async def listen(self):
        try:
            async for message in self.ws:
                data = json.loads(message)
                await self.handle_message(data)
        except websockets.exceptions.ConnectionClosed:
            self.is_connected = False
            print("WebSocket connection closed")
    
    async def handle_message(self, message: dict):
        event_type = message.get('type')
        if event_type in self.subscriptions:
            for callback in self.subscriptions[event_type]:
                try:
                    if asyncio.iscoroutinefunction(callback):
                        await callback(message)
                    else:
                        callback(message)
                except Exception as e:
                    print(f"Error in callback: {e}")
    
    def subscribe(self, event_type: str, callback: Callable, filters: Optional[dict] = None):
        if event_type not in self.subscriptions:
            self.subscriptions[event_type] = []
            
            # Send subscription message
            asyncio.create_task(self.send_subscription(event_type, filters))
        
        self.subscriptions[event_type].append(callback)
    
    async def send_subscription(self, event_type: str, filters: Optional[dict] = None):
        if self.ws and self.is_connected:
            message = {
                'type': 'subscribe',
                'events': [event_type]
            }
            if filters:
                message['filters'] = filters
            
            await self.ws.send(json.dumps(message))
    
    async def disconnect(self):
        if self.ws:
            await self.ws.close()
            self.is_connected = False

# Usage example
async def main():
    ws_client = AetherLockWebSocket('YOUR_JWT_TOKEN')
    await ws_client.connect()
    
    def handle_escrow_update(message):
        print(f"Escrow updated: {message['data']}")
    
    def handle_verification(message):
        print(f"Verification completed: {message['data']}")
    
    ws_client.subscribe('escrow.status_changed', handle_escrow_update)
    ws_client.subscribe('verification.completed', handle_verification)
    
    # Keep connection alive
    try:
        while ws_client.is_connected:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        await ws_client.disconnect()

if __name__ == "__main__":
    asyncio.run(main())
```

## Error Handling

### Connection Errors

```json
{
  "type": "error",
  "error": "CONNECTION_FAILED",
  "message": "Unable to establish WebSocket connection",
  "code": 1006,
  "timestamp": "2024-01-10T15:30:00Z"
}
```

### Authentication Errors

```json
{
  "type": "auth_error",
  "error": "INVALID_TOKEN",
  "message": "JWT token is invalid or expired",
  "code": 4001,
  "timestamp": "2024-01-10T15:30:00Z"
}
```

### Subscription Errors

```json
{
  "type": "subscription_error",
  "error": "INVALID_FILTER",
  "message": "Escrow ID filter is malformed",
  "subscriptionId": "sub_123456",
  "timestamp": "2024-01-10T15:30:00Z"
}
```

### Rate Limiting

```json
{
  "type": "rate_limit_exceeded",
  "message": "Too many subscription requests",
  "retryAfter": 60,
  "timestamp": "2024-01-10T15:30:00Z"
}
```

### AI Provider Errors

```json
{
  "type": "ai_provider_error",
  "error": "ARCANUM_TIMEOUT",
  "message": "Arcanum.ai request timeout, falling back to OpenAI",
  "provider": "arcanum-ai",
  "fallbackProvider": "openai",
  "timestamp": "2024-01-10T15:30:00Z"
}
```

```json
{
  "type": "ai_provider_error",
  "error": "ARCANUM_RATE_LIMIT",
  "message": "Arcanum.ai rate limit exceeded",
  "provider": "arcanum-ai",
  "retryAfter": 120,
  "timestamp": "2024-01-10T15:30:00Z"
}
```

## Best Practices

### Connection Management

1. **Implement Reconnection Logic**: Handle disconnections gracefully with exponential backoff
2. **Token Refresh**: Refresh JWT tokens before they expire
3. **Heartbeat/Ping**: Send periodic ping messages to keep connection alive
4. **Graceful Shutdown**: Properly close connections when application exits

### Subscription Management

1. **Filter Efficiently**: Use specific filters to reduce unnecessary events
2. **Unsubscribe Cleanup**: Always unsubscribe when components unmount
3. **Error Handling**: Implement error handlers for subscription failures
4. **Batch Subscriptions**: Group related subscriptions together

### Performance Optimization

1. **Event Batching**: Process multiple events in batches when possible
2. **Debouncing**: Debounce rapid UI updates from frequent events
3. **Memory Management**: Clean up event listeners and subscriptions
4. **Connection Pooling**: Reuse connections across application components

## Testing

### Mock WebSocket Server

```typescript
// Mock server for testing
class MockAetherLockWebSocket {
  private clients: Set<WebSocket> = new Set();
  
  constructor(port: number = 8080) {
    const server = new WebSocketServer({ port });
    
    server.on('connection', (ws) => {
      this.clients.add(ws);
      
      ws.on('message', (data) => {
        const message = JSON.parse(data.toString());
        this.handleMessage(ws, message);
      });
      
      ws.on('close', () => {
        this.clients.delete(ws);
      });
    });
  }
  
  private handleMessage(ws: WebSocket, message: any) {
    switch (message.type) {
      case 'auth':
        ws.send(JSON.stringify({ type: 'auth_success' }));
        break;
      case 'subscribe':
        ws.send(JSON.stringify({ 
          type: 'subscription_success',
          subscriptionId: 'mock_sub_123'
        }));
        break;
    }
  }
  
  // Simulate events for testing
  simulateEscrowUpdate(escrowId: string) {
    const event = {
      type: 'escrow.status_changed',
      timestamp: new Date().toISOString(),
      data: {
        escrowId,
        previousStatus: 'funded',
        newStatus: 'evidence_submitted'
      }
    };
    
    this.broadcast(event);
  }
  
  private broadcast(message: any) {
    const data = JSON.stringify(message);
    this.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(data);
      }
    });
  }
}
```

## Support

- **WebSocket Status**: [https://status.aetherlock.io/websocket](https://status.aetherlock.io/websocket)
- **Real-time Monitoring**: [https://monitor.aetherlock.io](https://monitor.aetherlock.io)
- **Developer Support**: [https://discord.gg/aetherlock-dev](https://discord.gg/aetherlock-dev)
- **Documentation**: [https://docs.aetherlock.io/websocket](https://docs.aetherlock.io/websocket)
