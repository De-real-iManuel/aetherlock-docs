# ZetaChain Integration

## Overview

ZetaChain serves as the omnichain orchestration layer for AetherLock, enabling seamless cross-chain escrow operations between Solana, Somnia, and other supported blockchains. As a Universal Blockchain, ZetaChain provides native cross-chain messaging, asset routing, and state synchronization capabilities that make AetherLock truly omnichain.

## ZetaChain's Role in AetherLock

### Omnichain Orchestration Layer
ZetaChain acts as the central coordination hub that:
- **Routes cross-chain messages** between different blockchain networks
- **Synchronizes escrow state** across all participating chains
- **Manages universal identity** through zkMe integration
- **Coordinates AI verification** results across chains
- **Handles cross-chain asset transfers** and settlements

### Key Benefits
- **Universal Connectivity**: Connect any blockchain without bridges
- **Native Asset Support**: Handle native assets (SOL, ETH, etc.) directly
- **Atomic Cross-Chain Operations**: Ensure transaction atomicity across chains
- **Unified State Management**: Single source of truth for escrow states
- **Gas Optimization**: Intelligent routing for minimal transaction costs

## Complete Universal App Contract

### Contract Architecture

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@zetachain/protocol-contracts/contracts/zevm/SystemContract.sol";
import "@zetachain/protocol-contracts/contracts/zevm/interfaces/zContract.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title AetherLockUniversal
 * @dev Universal App for cross-chain escrow operations on ZetaChain
 * Coordinates escrow creation, verification, and settlement across multiple chains
 */
contract AetherLockUniversal is zContract, ReentrancyGuard, Ownable {
    SystemContract public immutable systemContract;
    
    // Cross-chain escrow tracking
    mapping(uint256 => CrossChainEscrow) public escrows;
    mapping(bytes32 => uint256) public escrowsByHash;
    mapping(address => uint256[]) public userEscrows;
    
    // Chain configuration
    mapping(uint256 => ChainConfig) public supportedChains;
    mapping(uint256 => address) public chainGateways;
    
    // AI Oracle configuration
    address public aiOracleAuthority;
    mapping(bytes32 => bool) public processedVerifications;
    
    // Treasury configuration
    address public treasuryAddress;
    uint256 public treasuryFeePercent = 200; // 2% in basis points
    
    uint256 public nextEscrowId = 1;
    
    /// @dev Cross-chain escrow data structure
    struct CrossChainEscrow {
        uint256 escrowId;
        uint256 sourceChain;
        uint256 destinationChain;
        address sourcePayer;
        address destinationPayee;
        uint256 amount;
        address tokenAddress; // ZRC-20 token address on ZetaChain
        bytes32 taskMetadataHash;
        bytes32 evidenceHash;
        EscrowStatus status;
        VerificationResult verification;
        bytes32 kycHash;
        uint256 deadline;
        uint256 createdAt;
        uint256 treasuryFee;
    }
    
    /// @dev Chain configuration for supported networks
    struct ChainConfig {
        bool isSupported;
        string name;
        address gatewayAddress;
        uint256 minGasLimit;
        bool isEVM;
    }
    
    /// @dev AI verification result
    struct VerificationResult {
        uint8 confidenceScore;
        VerificationDecision decision;
        bytes32 analysisHash;
        uint256 verifiedAt;
        bytes signature; // Ed25519 signature from AI service
    }
    
    /// @dev Escrow status enumeration
    enum EscrowStatus {
        Created,
        Funded,
        PendingVerification,
        Verified,
        Disputed,
        Completed,
        Cancelled
    }
    
    /// @dev AI verification decision types
    enum VerificationDecision {
        Approved,
        Rejected,
        NeedsReview
    }
    
    // Events for cross-chain monitoring
    event CrossChainEscrowCreated(
        uint256 indexed escrowId,
        uint256 indexed sourceChain,
        uint256 indexed destinationChain,
        address sourcePayer,
        address destinationPayee,
        uint256 amount,
        address tokenAddress
    );
    
    event EscrowFunded(
        uint256 indexed escrowId,
        uint256 amount,
        uint256 treasuryFee
    );
    
    event EvidenceSubmitted(
        uint256 indexed escrowId,
        bytes32 evidenceHash,
        address submittedBy
    );
    
    event VerificationProcessed(
        uint256 indexed escrowId,
        VerificationDecision decision,
        uint8 confidenceScore,
        bytes32 analysisHash
    );
    
    event CrossChainSettlement(
        uint256 indexed escrowId,
        uint256 destinationChain,
        address payee,
        uint256 amount
    );
    
    event EscrowCancelled(
        uint256 indexed escrowId,
        address cancelledBy,
        uint256 refundAmount
    );
    
    /// @dev Custom errors for gas optimization
    error InvalidChain(uint256 chainId);
    error EscrowNotFound(uint256 escrowId);
    error InvalidStatus(EscrowStatus current, EscrowStatus required);
    error Unauthorized(address caller);
    error DeadlineExceeded(uint256 deadline, uint256 current);
    error InvalidAmount(uint256 amount);
    error InvalidVerification(bytes32 hash);
    error ChainNotSupported(uint256 chainId);
    
    constructor(
        address _systemContract,
        address _aiOracleAuthority,
        address _treasuryAddress
    ) {
        systemContract = SystemContract(_systemContract);
        aiOracleAuthority = _aiOracleAuthority;
        treasuryAddress = _treasuryAddress;
        
        // Initialize supported chains
        _initializeSupportedChains();
    }
    
    /// @dev Initialize configuration for supported blockchain networks
    function _initializeSupportedChains() private {
        // Solana configuration
        supportedChains[7000] = ChainConfig({
            isSupported: true,
            name: "Solana",
            gatewayAddress: address(0), // Solana uses different addressing
            minGasLimit: 0, // Solana uses different fee model
            isEVM: false
        });
        
        // Somnia testnet configuration
        supportedChains[50311] = ChainConfig({
            isSupported: true,
            name: "Somnia Testnet",
            gatewayAddress: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0, // Example address
            minGasLimit: 100000,
            isEVM: true
        });
        
        // Ethereum mainnet configuration
        supportedChains[1] = ChainConfig({
            isSupported: true,
            name: "Ethereum",
            gatewayAddress: 0xEbc14681c4B7E6cCf4Eb7B5C3a5b0b5b5b5b5b5b, // Example address
            minGasLimit: 150000,
            isEVM: true
        });
        
        // BSC configuration
        supportedChains[56] = ChainConfig({
            isSupported: true,
            name: "BSC",
            gatewayAddress: 0x1234567890123456789012345678901234567890, // Example address
            minGasLimit: 100000,
            isEVM: true
        });
    }
    
    /// @dev Create a new cross-chain escrow
    function createCrossChainEscrow(
        uint256 destinationChain,
        address destinationPayee,
        uint256 amount,
        address tokenAddress,
        bytes32 taskMetadataHash,
        uint256 deadline,
        bytes calldata kycProof
    ) external payable nonReentrant {
        // Validate inputs
        if (!supportedChains[destinationChain].isSupported) {
            revert ChainNotSupported(destinationChain);
        }
        if (amount == 0) revert InvalidAmount(amount);
        if (deadline <= block.timestamp) revert DeadlineExceeded(deadline, block.timestamp);
        
        // Verify KYC proof (simplified - in production, verify zkMe proof)
        bytes32 kycHash = keccak256(kycProof);
        require(_verifyKYCProof(msg.sender, kycProof), "Invalid KYC proof");
        
        uint256 escrowId = nextEscrowId++;
        uint256 treasuryFee = (amount * treasuryFeePercent) / 10000;
        
        // Create escrow record
        escrows[escrowId] = CrossChainEscrow({
            escrowId: escrowId,
            sourceChain: block.chainid,
            destinationChain: destinationChain,
            sourcePayer: msg.sender,
            destinationPayee: destinationPayee,
            amount: amount,
            tokenAddress: tokenAddress,
            taskMetadataHash: taskMetadataHash,
            evidenceHash: bytes32(0),
            status: EscrowStatus.Created,
            verification: VerificationResult({
                confidenceScore: 0,
                decision: VerificationDecision.Approved, // Default
                analysisHash: bytes32(0),
                verifiedAt: 0,
                signature: ""
            }),
            kycHash: kycHash,
            deadline: deadline,
            createdAt: block.timestamp,
            treasuryFee: treasuryFee
        });
        
        // Track escrow by hash and user
        bytes32 escrowHash = keccak256(abi.encodePacked(escrowId, msg.sender, destinationPayee));
        escrowsByHash[escrowHash] = escrowId;
        userEscrows[msg.sender].push(escrowId);
        
        emit CrossChainEscrowCreated(
            escrowId,
            block.chainid,
            destinationChain,
            msg.sender,
            destinationPayee,
            amount,
            tokenAddress
        );
        
        // Send cross-chain message to destination chain
        _sendCrossChainMessage(
            destinationChain,
            abi.encodeWithSignature(
                "onEscrowCreated(uint256,address,uint256,bytes32)",
                escrowId,
                destinationPayee,
                amount,
                taskMetadataHash
            )
        );
    }
    
    /// @dev Fund an existing escrow with tokens
    function fundEscrow(uint256 escrowId) external payable nonReentrant {
        CrossChainEscrow storage escrow = escrows[escrowId];
        if (escrow.escrowId == 0) revert EscrowNotFound(escrowId);
        if (escrow.status != EscrowStatus.Created) {
            revert InvalidStatus(escrow.status, EscrowStatus.Created);
        }
        if (msg.sender != escrow.sourcePayer) revert Unauthorized(msg.sender);
        
        uint256 totalAmount = escrow.amount + escrow.treasuryFee;
        
        // Handle different token types
        if (escrow.tokenAddress == address(0)) {
            // Native token (ZETA)
            require(msg.value == totalAmount, "Incorrect ZETA amount");
        } else {
            // ZRC-20 token
            require(msg.value == 0, "No ZETA needed for ZRC-20");
            
            // Transfer ZRC-20 tokens to this contract
            IZRC20(escrow.tokenAddress).transferFrom(
                msg.sender,
                address(this),
                totalAmount
            );
        }
        
        escrow.status = EscrowStatus.Funded;
        
        emit EscrowFunded(escrowId, escrow.amount, escrow.treasuryFee);
        
        // Notify destination chain about funding
        _sendCrossChainMessage(
            escrow.destinationChain,
            abi.encodeWithSignature(
                "onEscrowFunded(uint256,uint256)",
                escrowId,
                escrow.amount
            )
        );
    }
    
    /// @dev Submit evidence for task completion
    function submitEvidence(
        uint256 escrowId,
        bytes32 evidenceHash
    ) external nonReentrant {
        CrossChainEscrow storage escrow = escrows[escrowId];
        if (escrow.escrowId == 0) revert EscrowNotFound(escrowId);
        if (escrow.status != EscrowStatus.Funded) {
            revert InvalidStatus(escrow.status, EscrowStatus.Funded);
        }
        if (block.timestamp >= escrow.deadline) {
            revert DeadlineExceeded(escrow.deadline, block.timestamp);
        }
        
        // Allow submission from either payer or payee for flexibility
        require(
            msg.sender == escrow.sourcePayer || msg.sender == escrow.destinationPayee,
            "Unauthorized evidence submission"
        );
        
        escrow.evidenceHash = evidenceHash;
        escrow.status = EscrowStatus.PendingVerification;
        
        emit EvidenceSubmitted(escrowId, evidenceHash, msg.sender);
        
        // Trigger AI verification process
        _requestAIVerification(escrowId, evidenceHash);
    }
    
    /// @dev Process AI verification result (called by authorized AI oracle)
    function processVerification(
        uint256 escrowId,
        uint8 confidenceScore,
        VerificationDecision decision,
        bytes32 analysisHash,
        bytes calldata signature
    ) external nonReentrant {
        if (msg.sender != aiOracleAuthority) revert Unauthorized(msg.sender);
        
        CrossChainEscrow storage escrow = escrows[escrowId];
        if (escrow.escrowId == 0) revert EscrowNotFound(escrowId);
        if (escrow.status != EscrowStatus.PendingVerification) {
            revert InvalidStatus(escrow.status, EscrowStatus.PendingVerification);
        }
        
        // Prevent replay attacks
        bytes32 verificationHash = keccak256(abi.encodePacked(
            escrowId, confidenceScore, uint8(decision), analysisHash
        ));
        if (processedVerifications[verificationHash]) {
            revert InvalidVerification(verificationHash);
        }
        processedVerifications[verificationHash] = true;
        
        // Store verification result
        escrow.verification = VerificationResult({
            confidenceScore: confidenceScore,
            decision: decision,
            analysisHash: analysisHash,
            verifiedAt: block.timestamp,
            signature: signature
        });
        
        // Update escrow status based on AI decision
        if (decision == VerificationDecision.Approved) {
            escrow.status = EscrowStatus.Verified;
        } else if (decision == VerificationDecision.Rejected) {
            escrow.status = EscrowStatus.Funded; // Allow resubmission
        } else {
            escrow.status = EscrowStatus.Disputed; // Needs manual review
        }
        
        emit VerificationProcessed(escrowId, decision, confidenceScore, analysisHash);
        
        // If approved, initiate cross-chain settlement
        if (decision == VerificationDecision.Approved) {
            _initiateCrossChainSettlement(escrowId);
        }
    }
    
    /// @dev Release funds after successful verification
    function releaseFunds(uint256 escrowId) external nonReentrant {
        CrossChainEscrow storage escrow = escrows[escrowId];
        if (escrow.escrowId == 0) revert EscrowNotFound(escrowId);
        if (escrow.status != EscrowStatus.Verified) {
            revert InvalidStatus(escrow.status, EscrowStatus.Verified);
        }
        
        escrow.status = EscrowStatus.Completed;
        
        // Execute cross-chain settlement
        _executeCrossChainSettlement(escrowId);
    }
    
    /// @dev Cancel escrow and refund payer
    function cancelEscrow(uint256 escrowId) external nonReentrant {
        CrossChainEscrow storage escrow = escrows[escrowId];
        if (escrow.escrowId == 0) revert EscrowNotFound(escrowId);
        if (msg.sender != escrow.sourcePayer) revert Unauthorized(msg.sender);
        
        // Can only cancel before evidence submission
        require(
            escrow.status == EscrowStatus.Created || escrow.status == EscrowStatus.Funded,
            "Cannot cancel after evidence submission"
        );
        
        uint256 refundAmount = 0;
        if (escrow.status == EscrowStatus.Funded) {
            refundAmount = escrow.amount + escrow.treasuryFee;
            
            // Refund tokens
            if (escrow.tokenAddress == address(0)) {
                // Native ZETA refund
                payable(escrow.sourcePayer).transfer(refundAmount);
            } else {
                // ZRC-20 token refund
                IZRC20(escrow.tokenAddress).transfer(escrow.sourcePayer, refundAmount);
            }
        }
        
        escrow.status = EscrowStatus.Cancelled;
        
        emit EscrowCancelled(escrowId, msg.sender, refundAmount);
        
        // Notify destination chain about cancellation
        _sendCrossChainMessage(
            escrow.destinationChain,
            abi.encodeWithSignature(
                "onEscrowCancelled(uint256)",
                escrowId
            )
        );
    }
    
    /// @dev ZetaChain Universal App interface - handle incoming cross-chain calls
    function onCall(
        MessageContext calldata context,
        address zrc20,
        uint256 amount,
        bytes calldata message
    ) external override {
        // Decode the incoming message
        (string memory method, bytes memory data) = abi.decode(message, (string, bytes));
        
        if (keccak256(bytes(method)) == keccak256("escrowCreated")) {
            _handleEscrowCreated(context, data);
        } else if (keccak256(bytes(method)) == keccak256("escrowFunded")) {
            _handleEscrowFunded(context, data);
        } else if (keccak256(bytes(method)) == keccak256("evidenceSubmitted")) {
            _handleEvidenceSubmitted(context, data);
        } else if (keccak256(bytes(method)) == keccak256("settlementRequest")) {
            _handleSettlementRequest(context, zrc20, amount, data);
        }
    }
    
    /// @dev Handle cross-chain call reversion
    function onRevert(RevertContext calldata revertContext) external override {
        // Handle failed cross-chain operations
        // Log the failure and potentially retry or refund
        
        // Decode the original message to understand what failed
        (uint256 escrowId, string memory operation) = abi.decode(
            revertContext.revertMessage, 
            (uint256, string)
        );
        
        CrossChainEscrow storage escrow = escrows[escrowId];
        
        if (keccak256(bytes(operation)) == keccak256("settlement")) {
            // Settlement failed, mark for manual intervention
            escrow.status = EscrowStatus.Disputed;
        }
        
        // Emit event for monitoring
        emit CrossChainOperationFailed(escrowId, operation, revertContext.revertMessage);
    }
    
    /// @dev Handle cross-chain call abortion
    function onAbort(
        MessageContext calldata context,
        address zrc20,
        uint256 amount,
        bytes calldata message
    ) external override {
        // Handle aborted cross-chain operations
        // Similar to onRevert but for aborted transactions
        
        (uint256 escrowId, string memory operation) = abi.decode(message, (uint256, string));
        
        CrossChainEscrow storage escrow = escrows[escrowId];
        escrow.status = EscrowStatus.Disputed; // Mark for manual review
        
        emit CrossChainOperationAborted(escrowId, operation);
    }
    
    // Internal helper functions
    
    /// @dev Send cross-chain message to destination chain
    function _sendCrossChainMessage(uint256 destinationChain, bytes memory message) private {
        ChainConfig memory config = supportedChains[destinationChain];
        require(config.isSupported, "Destination chain not supported");
        
        if (config.isEVM) {
            // Send to EVM-compatible chain
            systemContract.wZeta().approve(address(systemContract), 0.1 ether); // Gas fee
            
            systemContract.onCall(
                destinationChain,
                config.gatewayAddress,
                0.1 ether,
                message,
                config.minGasLimit
            );
        } else {
            // Handle non-EVM chains (like Solana) differently
            // This would require custom message formatting and routing
            _sendToNonEVMChain(destinationChain, message);
        }
    }
    
    /// @dev Handle non-EVM chain messaging (e.g., Solana)
    function _sendToNonEVMChain(uint256 chainId, bytes memory message) private {
        // Custom implementation for non-EVM chains
        // This would involve encoding the message in a format
        // that can be processed by the destination chain
        
        if (chainId == 7000) { // Solana
            // Encode message for Solana program
            bytes memory solanaMessage = abi.encode(
                "aetherlock_cross_chain",
                message
            );
            
            // U